{
    "docs": [
        {
            "location": "/", 
            "text": "TypedTables.jl\n\n\nSimple, fast, column-based storage for data analysis in Julia.\n\n\n\n\nIntroduction\n\n\nTypedTables.jl\n provides two column-based storage containers: \nTable\n and \nFlexTable\n, both of which represent an array of \nNamedTuple\ns. This package is designed to be lightweight, easy-to-use and fast, and presents a very minimal new interface to learn.\n\n\nData manipulation is possible throught the tools built into Julia (such as \nmap\n, \nfilter\n, and \nreduce\n) and those provide by \nSplitApplyCombine.jl\n (like \ngroup\n and \ninnerjoin\n). You can speed up data analysis tasks with acceleration indices, by using the \nAcceleratedArrays.jl\n package. This package is integrated the \nTables.jl\n interface, and therefore the rest of the data ecosystem such as \nQuery.jl\n. This documentation includes examples on how to integrate with these packages for a complete data analysis workflow.\n\n\n\n\nInstallation\n\n\nStart Julia 1.0, and press \n]\n to enter \"package\" mode. Then type:\n\n\npkg\n add TypedTables\n\n\n\n\nThat's it!\n\n\n\n\nQuick start\n\n\nHere's a table:\n\n\njulia\n using TypedTables\n\njulia\n t = Table(a = [1, 2, 3], b = [2.0, 4.0, 6.0])\nTable with 2 columns and 3 rows:\n     a  b\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 1  2.0\n 2 \u2502 2  4.0\n 3 \u2502 3  6.0\n\n\n\n\nNow you can read \nthe \ntutorial\n to find out what to do with it.", 
            "title": "Home"
        }, 
        {
            "location": "/#typedtablesjl", 
            "text": "Simple, fast, column-based storage for data analysis in Julia.", 
            "title": "TypedTables.jl"
        }, 
        {
            "location": "/#introduction", 
            "text": "TypedTables.jl  provides two column-based storage containers:  Table  and  FlexTable , both of which represent an array of  NamedTuple s. This package is designed to be lightweight, easy-to-use and fast, and presents a very minimal new interface to learn.  Data manipulation is possible throught the tools built into Julia (such as  map ,  filter , and  reduce ) and those provide by  SplitApplyCombine.jl  (like  group  and  innerjoin ). You can speed up data analysis tasks with acceleration indices, by using the  AcceleratedArrays.jl  package. This package is integrated the  Tables.jl  interface, and therefore the rest of the data ecosystem such as  Query.jl . This documentation includes examples on how to integrate with these packages for a complete data analysis workflow.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "Start Julia 1.0, and press  ]  to enter \"package\" mode. Then type:  pkg  add TypedTables  That's it!", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here's a table:  julia  using TypedTables\n\njulia  t = Table(a = [1, 2, 3], b = [2.0, 4.0, 6.0])\nTable with 2 columns and 3 rows:\n     a  b\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 1  2.0\n 2 \u2502 2  4.0\n 3 \u2502 3  6.0  Now you can read  the  tutorial  to find out what to do with it.", 
            "title": "Quick start"
        }, 
        {
            "location": "/man/tutorial/", 
            "text": "Quick start tutorial\n\n\nAfter reading this tutorial, you should be able to use Julia to perform a range of data analysis tasks. Only basic knowledge of Julia is assumed, such as how to install packages and use an array.\n\n\n\n\nMaking and using a \nTable\n\n\nIt's simple to get started and create a table!\n\n\nA \nTable\n is a wrapper around column arrays. Suppose you have an array containing names and an array containing ages, then you can create a table with two columns:\n\n\njulia\n t = Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\n\n\n\nA \nTable\n behaves as a Julia array that contains named tuples for each row. Each row is a single element - you should consider the above as a one-dimensional container with three elements, rather than as a two-dimensional \"matrix\" of six cells. Another name for a collection of named tuples is a \"relation\", and \nTable\ns are useful for performing \nrelational algebra\n.\n\n\nYou can access elements (rows) exactly like any other Julia array.\n\n\njulia\n t[1]\n(name = \nAlice\n, age = 25)\n\njulia\n t[1:2]\nTable with 2 columns and 2 rows:\n     name   age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice  25\n 2 \u2502 Bob    42\n\n\n\n\nA element (row) of the table can be updated with the usual array syntax.\n\n\njulia\n t[1] = (name = \nAlice\n, age = 26);  # Alice had a birthday!\n\njulia\n t\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    26\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\n\n\n\nYou can easily access a column by the tables \"properties\", use the \n.\n operator.\n\n\njulia\n t.name\n3-element Array{String,1}:\n \nAlice\n  \n \nBob\n    \n \nCharlie\n\n\n\n\n\nYou can ask what the properties (column names) of a \nTable\n with the \npropertynames\n function (as well as the \ncolumnnames\n function).\n\n\njulia\n propertynames(t)\n(:name, :age)\n\n\n\n\nRecall that \n:name\n is a \nSymbol\n - which you can think of a special kind of string that the compiler works with when considering Julia code itself.\n\n\nIndividual cells can be accessed in two, symmetric ways.\n\n\njulia\n t.name[2]\n\nBob\n\n\njulia\n t[2].name\n\nBob\n\n\n\n\n\nNote that the first way is more efficient, and recommended, because in the second case the intermediate value \nt[2]\n is assembled from the elements of \nall\n the columns. The first syntax also supports updating.\n\n\njulia\n t.name[2] = \nRobert\n;  # No nicknames here...\n\njulia\n t\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    26\n 2 \u2502 Robert   42\n 3 \u2502 Charlie  37\n\n\n\n\nThe names and number of columns in a \nTable\n are fixed and immutable. You cannot add, remove, or delete columns from a \nTable\n. Instead, a new table should be formed - you can even call the new table by the old variable name, if you want.\n\n\nMultiple tables and additional columns can be created in the one \nTable\n constructor. For example, it is easy to add an additional column.\n\n\njulia\n Table(t; lastname = [\nSmith\n, \nSmith\n, \nSmith\n])\nTable with 3 columns and 3 rows:\n     name     age  lastname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    26   Smith\n 2 \u2502 Robert   42   Smith\n 3 \u2502 Charlie  37   Smith\n\n\n\n\nAnd we can delete a column by setting it to \nnothing\n.\n\n\njulia\n Table(t; age = nothing)\nTable with 1 column and 3 rows:\n     name\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Robert\n 3 \u2502 Charlie\n\n\n\n\nBecause the names and types of your columns are fixed on any line of code, Julia's compiler is able to produce lightning fast machine code for processing your data.\n\n\n\n\nFlexTable\n\n\nSometimes, it \nis\n handy to be able to add, remove and rename columns without create a new \nTable\n container. The \nFlexTable\n type allows for this.\n\n\njulia\n ft = FlexTable(names = [\nAlice\n, \nBob\n, \nCharlie\n])\nFlexTable with 1 column and 3 rows:\n     names\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Bob\n 3 \u2502 Charlie\n\njulia\n ft.age = [25, 42, 37];\n\njulia\n ft\nFlexTable with 2 columns and 3 rows:\n     names    age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\n\n\n\nA column can be deleted by setting it to \nnothing\n.\n\n\njulia\n ft.age = nothing;\n\njulia\n ft\nFlexTable with 1 column and 3 rows:\n     names\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Bob\n 3 \u2502 Charlie\n\n\n\n\nA \nFlexTable\n will be just as fast as a \nTable\n in most contexts. However, Julia's compiler will not be able to predict in advance the names and types of the columns. The main thing to watch is that an explicit \nfor\n loop over the rows of a \nFlexTable\n will be a bit slower than that of a \nTable\n - but all the operations demonstrated in this tutorial will be just as speedy!\n\n\n\n\nMissing data\n\n\nThe recommended way to handle missing data in Julia is by using \nmissing\n, which is a value with its very own type \nMissing\n. For example, we may create a table where some people haven't specified their age.\n\n\njulia\n Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, missing, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      missing\n 3 \u2502 Charlie  37\n\n\n\n\nIn Julia, \nmissing\n values propagate safely where this is appropriate. For example, \nmissing + 1\n is also \nmissing\n - if we didn't know the value before, we still don't after adding \n1\n. This makes working with missing data simple and pain-free, and Julia's optimizing compiler also makes it extremely fast.\n\n\n\n\nLoading and saving data from files\n\n\nTypedTables.jl\n integrates seemlessly into an ecosystem of Julia I/O packages. For example, we can use \nCSV.jl\n to load and save CSV files. Let's say we have a CSV file called \ninput.csv\n with the following data.\n\n\nname,age\nAlice,25\nBob,42\nCharlie,37\n\n\n\n\nWe can load this file from disk using the \nCSV.read\n function.\n\n\njulia\n using CSV\n\njulia\n t = CSV.read(\ninput.csv\n, Table)\nFlexTable with 2 columns and 3 rows:\n     names    age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\n\n\n\nSimilary, we can write a table to a new file \noutput.csv\n with the \nCSV.write\n function.\n\n\njulia\n CSV.write(\noutput.csv\n, t)\n\n\n\n\n\n\nFinding data\n\n\nJulia's broadcasting and indexing syntax can work together to make it easy to find rows of data based on given creteria. Suppose we wanted to find all the \"old\" people in the  table.\n\n\njulia\n t = Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia\n t.age .\n 40\n3-element BitArray{1}:\n false\n  true\n false\n\n\n\n\nBob and Alice might disagree about what \"old\" means, but here we have identified all the people over 40 years of age. Note the difference between the \"scalar\" operator \n and the  \"broadcasting\" operator \n.\n.\n\n\nWe can use \"logical\" indexing to collect the rows for which the above predicate is \ntrue\n.\n\n\njulia\n t[t.age .\n 40]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42\n\n\n\n\nData can also be found with Julia's standard \nfilter\n and \nfindall\n functions.\n\n\n\n\nSummarizing data\n\n\nJulia has a range of standard functions for asking common questions about a set of data.\n\n\nFor example, we can use the \nin\n operator to test if an entry is in a column.\n\n\njulia\n \nBob\n in t.name\ntrue\n\n\n\n\nOr if a given row is \nin\n the table.\n\n\njulia\n (name = \nBob\n, age = 41) in t\nfalse\n\n\n\n\n(Bob is older than that).\n\n\nWe can \nsum\n columns, and with the \nStatistics\n standard library, we can find the \nmean\n, \nmedian\n, and so-on.\n\n\njulia\n sum(t.age)\n104\n\njulia\n using Statistics\n\njulia\n mean(t.age)\n34.666666666666664\n\njulia\n median(t.age)\n37.0\n\n\n\n\nBy these metrics, Bob's age \nis\n above average!\n\n\n\n\nMapping data\n\n\nFunctions which map rows to new rows can be used to create new tables. \n\n\nBelow, we create an annonymous function which takes a row containing a name and an age, and returns an inital letter and whether the person is old (greater than 40), and use Julia's built-in \nmap\n function.\n\n\njulia\n map(row -\n (initial = first(row.name), is_old = row.age \n 40), t)\nTable with 2 columns and 3 rows:\n     initial  is_old\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 A        false\n 2 \u2502 B        true\n 3 \u2502 C        false\n\n\n\n\nWriting anonymous functions can become laborious when dealing with many rows, so the convenience macros \n@Select\n and \n@Compute\n are provided to aid in their construction.\n\n\nThe \n@Select\n macro returns a function that can map a row to a new row (or a table to a new table) by defining a functional mapping for each output column. The above example can alternatively be written as:\n\n\njulia\n map(@Select(initial = first($name), is_old = $age \n 40), t)\nTable with 2 columns and 3 rows:\n     initial  is_old\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 A        false\n 2 \u2502 B        true\n 3 \u2502 C        false\n\n\n\n\nFor shorthand, the \n= ...\n can be ommited to simply extract a column. For example, we can reorder the columns via\n\n\njulia\n @Select(age, name)(t)\nTable with 2 columns and 3 rows:\n     age  name\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 25   Alice\n 2 \u2502 42   Bob\n 3 \u2502 37   Charlie\n\n\n\n\n(Note that here we \"select\" columns directly, rather than using \nmap\n to select the fields of each row.)\n\n\nThe \n@Compute\n macro returns a function that maps a row to a value. As for \n@Select\n, the input column names are prepended with \n$\n, for example:\n\n\njulia\n map(@Compute($name), t)\n3-element Array{String,1}:\n \nAlice\n  \n \nBob\n    \n \nCharlie\n\n\n\n\n\nUnlike an anonymous function, these two macros create an introspectable function that allows computations to take advantage of columnar storage and advanced features like acceleration indices. You may find calculations may be performed faster with the macros for a wide variety of functions like \nmap\n, \nbroadcast\n, \nfilter\n, \nfindall\n, \nreduce\n, \ngroup\n and \ninnerjoin\n. For instance, the example above simply extracts the \nname\n column from \nt\n, without performing an explicit map.\n\n\n\n\nGrouping data\n\n\nFrequently, one wishes to group and process data using a so-called \"split-apply-combine\" methodology. \nTypedTables\n is a lightweight package and does not provide this functionality directly - but it has been designed carefully to work optimally with external packages.\n\n\nOne such package is \nSplitApplyCombine.jl\n, which provides common operations for grouping and joining data (if you wish, you may view its documentation \nhere\n).\n\n\nWe will demonstrate grouping data with a slightly more complex dataset.\n\n\njulia\n t2 = Table(firstname = [\nAlice\n, \nBob\n, \nCharlie\n, \nAdam\n, \nEve\n, \nCindy\n, \nArthur\n], lastname = [\nSmith\n, \nSmith\n, \nSmith\n, \nWilliams\n, \nWilliams\n, \nBrown\n, \nKing\n], age = [25, 42, 37, 65, 18, 33, 54])\nTable with 3 columns and 7 rows:\n     firstname  lastname  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice      Smith     25\n 2 \u2502 Bob        Smith     42\n 3 \u2502 Charlie    Smith     37\n 4 \u2502 Adam       Williams  65\n 5 \u2502 Eve        Williams  18\n 6 \u2502 Cindy      Brown     33\n 7 \u2502 Arthur     King      54\n\n\n\n\nLet us begin with basic usage of the \ngroup\n function from \nSplitApplyCombine\n, where we wish to group firstnames by their initial letter.\n\n\njulia\n using SplitApplyCombine\n\njulia\n group(first, t2.firstname)\nDict{Char,Array{String,1}} with 4 entries:\n  'C' =\n [\nCharlie\n, \nCindy\n]\n  'A' =\n [\nAlice\n, \nAdam\n, \nArthur\n]\n  'E' =\n [\nEve\n]\n  'B' =\n [\nBob\n]\n\n\n\n\nThe \ngroup\n function returns a dictionary (\nDict\n) where the grouping key is calculated on each row by the function passed as the first argument - in this case \nfirst\n. We can see the firstnames starting with the letter \nA\n belong to the same group, and so on.\n\n\nSometimes you may want to transform the grouped data - you can do so by passing a second mapping function. For example, we may want to group firstnames by lastname.\n\n\njulia\n group(@Compute($lastname), $Compute($firstname), t2)\nDict{String,Array{String,1}} with 4 entries:\n  \nKing\n     =\n [\nArthur\n]\n  \nWilliams\n =\n [\nAdam\n, \nEve\n]\n  \nBrown\n    =\n [\nCindy\n]\n  \nSmith\n    =\n [\nAlice\n, \nBob\n, \nCharlie\n]\n\n\n\n\nNote that the returned structure is still not a \nTable\n at all - it is a dictionary with the unique \nlastname\n values as keys, returing (non-tabular) arrays of \nfirstname\n.\n\n\nIf instead, our group elements are rows (named tuples), each group will itslef be a table. For example, we can keep the entire row by dropping the second function.\n\n\njulia\n families = group(@Compute($lastname), t2)\nGroups{String,Any,Table{NamedTuple{(:firstname, :lastname, :age),Tuple{String,String,Int64}},1,NamedTuple{(:firstname, :lastname, :age),Tuple{Array{String,1},Array{String,1},Array{Int64,1}}}},Dict{String,Array{Int64,1}}} with 4 entries:\n  \nKing\n     =\n Table with 3 columns and 1 row:\u2026\n  \nWilliams\n =\n Table with 3 columns and 2 rows:\u2026\n  \nBrown\n    =\n Table with 3 columns and 1 row:\u2026\n  \nSmith\n    =\n Table with 3 columns and 3 rows:\u2026\n\n\n\n\nThe results are only summarized above (for compactness), but can be easily accessed.\n\n\njulia\n families[\nSmith\n]\nTable with 3 columns and 3 rows:\n     firstname  lastname  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice      Smith     25\n 2 \u2502 Bob        Smith     42\n 3 \u2502 Charlie    Smith     37\n\n\n\n\nThere are also more advanced functions \ngroupreduce\n, \ngroupinds\n and \ngroupview\n, which may help you perform your analysis more succinctly and faster, and are covered in later sections of this manual.\n\n\n\n\nJoining data\n\n\nA very common relational operation is to \njoin\n the data from two tables based on certain commonalities, such as the values matching in two columns. \nSplitApplyCombine.jl\n provides an \ninnerjoin\n function for precisely this (please note that \njoin\n is a Julia operation to concatenate strings).\n\n\nLet's suppose we have a small database of customers, and the items they have ordered from an online store.\n\n\njulia\n customers = Table(id = 1:3, name = [\nAlice\n, \nBob\n, \nCharlie\n], address = [\n12 Beach Street\n, \n163 Moon Road\n, \n6 George Street\n])\nTable with 3 columns and 3 rows:\n     id  name     address\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 1   Alice    12 Beach Street\n 2 \u2502 2   Bob      163 Moon Road\n 3 \u2502 3   Charlie  6 George Street\n\njulia\n orders = Table(customer_id = [2, 2, 3, 3], items = [\nSocks\n, \nTie\n, \nShirt\n, \nUnderwear\n])\nTable with 2 columns and 4 rows:\n     customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2            Socks\n 2 \u2502 2            Tie\n 3 \u2502 3            Shirt\n 4 \u2502 3            Underwear\n\n\n\n\nHere, these two tables are related by the customer's \nid\n. We can join the two tables on this column to determine the \naddress\n that we need to send the \nitems\n to. The \ninnerjoin\n function expects two functions, to describe the joining key of the first table and the joining key of the second table. We will use \ngetproperty\n to select the columns.\n\n\njulia\n innerjoin(@Compute($id), @Compute($customer_id), customers, orders)\nTable with 5 columns and 4 rows:\n     id  name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2   Bob      163 Moon Road    2            Socks\n 2 \u2502 2   Bob      163 Moon Road    2            Tie\n 3 \u2502 3   Charlie  6 George Street  3            Shirt\n 4 \u2502 3   Charlie  6 George Street  3            Underwear\n\n\n\n\nBy default, \ninnerjoin\n will \nmerge\n all of the columns. Like \ngroup\n, the \ninnerjoin\n function can accept an additional function to describe a mapping to desired output (as well as a comparison operation on the keys). The more advanced features of \ninnerjoin\n and other types of joins are covered in later sections of this manual.\n\n\n\n\nProgressing onwards\n\n\nCongratulations on completing the introductory tutorial. You should now know enough basics to get started with data analysis in Julia using \nTypedTables.jl\n and related packages.\n\n\nThe following setions of the manual demonstrate more advanced techniques, explain the  design of this (and related) packages, and provide an API reference.", 
            "title": "Quick start tutorial"
        }, 
        {
            "location": "/man/tutorial/#quick-start-tutorial", 
            "text": "After reading this tutorial, you should be able to use Julia to perform a range of data analysis tasks. Only basic knowledge of Julia is assumed, such as how to install packages and use an array.", 
            "title": "Quick start tutorial"
        }, 
        {
            "location": "/man/tutorial/#making-and-using-a-table", 
            "text": "It's simple to get started and create a table!  A  Table  is a wrapper around column arrays. Suppose you have an array containing names and an array containing ages, then you can create a table with two columns:  julia  t = Table(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37  A  Table  behaves as a Julia array that contains named tuples for each row. Each row is a single element - you should consider the above as a one-dimensional container with three elements, rather than as a two-dimensional \"matrix\" of six cells. Another name for a collection of named tuples is a \"relation\", and  Table s are useful for performing  relational algebra .  You can access elements (rows) exactly like any other Julia array.  julia  t[1]\n(name =  Alice , age = 25)\n\njulia  t[1:2]\nTable with 2 columns and 2 rows:\n     name   age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice  25\n 2 \u2502 Bob    42  A element (row) of the table can be updated with the usual array syntax.  julia  t[1] = (name =  Alice , age = 26);  # Alice had a birthday!\n\njulia  t\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    26\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37  You can easily access a column by the tables \"properties\", use the  .  operator.  julia  t.name\n3-element Array{String,1}:\n  Alice   \n  Bob     \n  Charlie   You can ask what the properties (column names) of a  Table  with the  propertynames  function (as well as the  columnnames  function).  julia  propertynames(t)\n(:name, :age)  Recall that  :name  is a  Symbol  - which you can think of a special kind of string that the compiler works with when considering Julia code itself.  Individual cells can be accessed in two, symmetric ways.  julia  t.name[2] Bob \n\njulia  t[2].name Bob   Note that the first way is more efficient, and recommended, because in the second case the intermediate value  t[2]  is assembled from the elements of  all  the columns. The first syntax also supports updating.  julia  t.name[2] =  Robert ;  # No nicknames here...\n\njulia  t\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    26\n 2 \u2502 Robert   42\n 3 \u2502 Charlie  37  The names and number of columns in a  Table  are fixed and immutable. You cannot add, remove, or delete columns from a  Table . Instead, a new table should be formed - you can even call the new table by the old variable name, if you want.  Multiple tables and additional columns can be created in the one  Table  constructor. For example, it is easy to add an additional column.  julia  Table(t; lastname = [ Smith ,  Smith ,  Smith ])\nTable with 3 columns and 3 rows:\n     name     age  lastname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    26   Smith\n 2 \u2502 Robert   42   Smith\n 3 \u2502 Charlie  37   Smith  And we can delete a column by setting it to  nothing .  julia  Table(t; age = nothing)\nTable with 1 column and 3 rows:\n     name\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Robert\n 3 \u2502 Charlie  Because the names and types of your columns are fixed on any line of code, Julia's compiler is able to produce lightning fast machine code for processing your data.", 
            "title": "Making and using a Table"
        }, 
        {
            "location": "/man/tutorial/#flextable", 
            "text": "Sometimes, it  is  handy to be able to add, remove and rename columns without create a new  Table  container. The  FlexTable  type allows for this.  julia  ft = FlexTable(names = [ Alice ,  Bob ,  Charlie ])\nFlexTable with 1 column and 3 rows:\n     names\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Bob\n 3 \u2502 Charlie\n\njulia  ft.age = [25, 42, 37];\n\njulia  ft\nFlexTable with 2 columns and 3 rows:\n     names    age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37  A column can be deleted by setting it to  nothing .  julia  ft.age = nothing;\n\njulia  ft\nFlexTable with 1 column and 3 rows:\n     names\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Bob\n 3 \u2502 Charlie  A  FlexTable  will be just as fast as a  Table  in most contexts. However, Julia's compiler will not be able to predict in advance the names and types of the columns. The main thing to watch is that an explicit  for  loop over the rows of a  FlexTable  will be a bit slower than that of a  Table  - but all the operations demonstrated in this tutorial will be just as speedy!", 
            "title": "FlexTable"
        }, 
        {
            "location": "/man/tutorial/#missing-data", 
            "text": "The recommended way to handle missing data in Julia is by using  missing , which is a value with its very own type  Missing . For example, we may create a table where some people haven't specified their age.  julia  Table(name = [ Alice ,  Bob ,  Charlie ], age = [25, missing, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      missing\n 3 \u2502 Charlie  37  In Julia,  missing  values propagate safely where this is appropriate. For example,  missing + 1  is also  missing  - if we didn't know the value before, we still don't after adding  1 . This makes working with missing data simple and pain-free, and Julia's optimizing compiler also makes it extremely fast.", 
            "title": "Missing data"
        }, 
        {
            "location": "/man/tutorial/#loading-and-saving-data-from-files", 
            "text": "TypedTables.jl  integrates seemlessly into an ecosystem of Julia I/O packages. For example, we can use  CSV.jl  to load and save CSV files. Let's say we have a CSV file called  input.csv  with the following data.  name,age\nAlice,25\nBob,42\nCharlie,37  We can load this file from disk using the  CSV.read  function.  julia  using CSV\n\njulia  t = CSV.read( input.csv , Table)\nFlexTable with 2 columns and 3 rows:\n     names    age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37  Similary, we can write a table to a new file  output.csv  with the  CSV.write  function.  julia  CSV.write( output.csv , t)", 
            "title": "Loading and saving data from files"
        }, 
        {
            "location": "/man/tutorial/#finding-data", 
            "text": "Julia's broadcasting and indexing syntax can work together to make it easy to find rows of data based on given creteria. Suppose we wanted to find all the \"old\" people in the  table.  julia  t = Table(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia  t.age .  40\n3-element BitArray{1}:\n false\n  true\n false  Bob and Alice might disagree about what \"old\" means, but here we have identified all the people over 40 years of age. Note the difference between the \"scalar\" operator   and the  \"broadcasting\" operator  . .  We can use \"logical\" indexing to collect the rows for which the above predicate is  true .  julia  t[t.age .  40]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42  Data can also be found with Julia's standard  filter  and  findall  functions.", 
            "title": "Finding data"
        }, 
        {
            "location": "/man/tutorial/#summarizing-data", 
            "text": "Julia has a range of standard functions for asking common questions about a set of data.  For example, we can use the  in  operator to test if an entry is in a column.  julia   Bob  in t.name\ntrue  Or if a given row is  in  the table.  julia  (name =  Bob , age = 41) in t\nfalse  (Bob is older than that).  We can  sum  columns, and with the  Statistics  standard library, we can find the  mean ,  median , and so-on.  julia  sum(t.age)\n104\n\njulia  using Statistics\n\njulia  mean(t.age)\n34.666666666666664\n\njulia  median(t.age)\n37.0  By these metrics, Bob's age  is  above average!", 
            "title": "Summarizing data"
        }, 
        {
            "location": "/man/tutorial/#mapping-data", 
            "text": "Functions which map rows to new rows can be used to create new tables.   Below, we create an annonymous function which takes a row containing a name and an age, and returns an inital letter and whether the person is old (greater than 40), and use Julia's built-in  map  function.  julia  map(row -  (initial = first(row.name), is_old = row.age   40), t)\nTable with 2 columns and 3 rows:\n     initial  is_old\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 A        false\n 2 \u2502 B        true\n 3 \u2502 C        false  Writing anonymous functions can become laborious when dealing with many rows, so the convenience macros  @Select  and  @Compute  are provided to aid in their construction.  The  @Select  macro returns a function that can map a row to a new row (or a table to a new table) by defining a functional mapping for each output column. The above example can alternatively be written as:  julia  map(@Select(initial = first($name), is_old = $age   40), t)\nTable with 2 columns and 3 rows:\n     initial  is_old\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 A        false\n 2 \u2502 B        true\n 3 \u2502 C        false  For shorthand, the  = ...  can be ommited to simply extract a column. For example, we can reorder the columns via  julia  @Select(age, name)(t)\nTable with 2 columns and 3 rows:\n     age  name\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 25   Alice\n 2 \u2502 42   Bob\n 3 \u2502 37   Charlie  (Note that here we \"select\" columns directly, rather than using  map  to select the fields of each row.)  The  @Compute  macro returns a function that maps a row to a value. As for  @Select , the input column names are prepended with  $ , for example:  julia  map(@Compute($name), t)\n3-element Array{String,1}:\n  Alice   \n  Bob     \n  Charlie   Unlike an anonymous function, these two macros create an introspectable function that allows computations to take advantage of columnar storage and advanced features like acceleration indices. You may find calculations may be performed faster with the macros for a wide variety of functions like  map ,  broadcast ,  filter ,  findall ,  reduce ,  group  and  innerjoin . For instance, the example above simply extracts the  name  column from  t , without performing an explicit map.", 
            "title": "Mapping data"
        }, 
        {
            "location": "/man/tutorial/#grouping-data", 
            "text": "Frequently, one wishes to group and process data using a so-called \"split-apply-combine\" methodology.  TypedTables  is a lightweight package and does not provide this functionality directly - but it has been designed carefully to work optimally with external packages.  One such package is  SplitApplyCombine.jl , which provides common operations for grouping and joining data (if you wish, you may view its documentation  here ).  We will demonstrate grouping data with a slightly more complex dataset.  julia  t2 = Table(firstname = [ Alice ,  Bob ,  Charlie ,  Adam ,  Eve ,  Cindy ,  Arthur ], lastname = [ Smith ,  Smith ,  Smith ,  Williams ,  Williams ,  Brown ,  King ], age = [25, 42, 37, 65, 18, 33, 54])\nTable with 3 columns and 7 rows:\n     firstname  lastname  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice      Smith     25\n 2 \u2502 Bob        Smith     42\n 3 \u2502 Charlie    Smith     37\n 4 \u2502 Adam       Williams  65\n 5 \u2502 Eve        Williams  18\n 6 \u2502 Cindy      Brown     33\n 7 \u2502 Arthur     King      54  Let us begin with basic usage of the  group  function from  SplitApplyCombine , where we wish to group firstnames by their initial letter.  julia  using SplitApplyCombine\n\njulia  group(first, t2.firstname)\nDict{Char,Array{String,1}} with 4 entries:\n  'C' =  [ Charlie ,  Cindy ]\n  'A' =  [ Alice ,  Adam ,  Arthur ]\n  'E' =  [ Eve ]\n  'B' =  [ Bob ]  The  group  function returns a dictionary ( Dict ) where the grouping key is calculated on each row by the function passed as the first argument - in this case  first . We can see the firstnames starting with the letter  A  belong to the same group, and so on.  Sometimes you may want to transform the grouped data - you can do so by passing a second mapping function. For example, we may want to group firstnames by lastname.  julia  group(@Compute($lastname), $Compute($firstname), t2)\nDict{String,Array{String,1}} with 4 entries:\n   King      =  [ Arthur ]\n   Williams  =  [ Adam ,  Eve ]\n   Brown     =  [ Cindy ]\n   Smith     =  [ Alice ,  Bob ,  Charlie ]  Note that the returned structure is still not a  Table  at all - it is a dictionary with the unique  lastname  values as keys, returing (non-tabular) arrays of  firstname .  If instead, our group elements are rows (named tuples), each group will itslef be a table. For example, we can keep the entire row by dropping the second function.  julia  families = group(@Compute($lastname), t2)\nGroups{String,Any,Table{NamedTuple{(:firstname, :lastname, :age),Tuple{String,String,Int64}},1,NamedTuple{(:firstname, :lastname, :age),Tuple{Array{String,1},Array{String,1},Array{Int64,1}}}},Dict{String,Array{Int64,1}}} with 4 entries:\n   King      =  Table with 3 columns and 1 row:\u2026\n   Williams  =  Table with 3 columns and 2 rows:\u2026\n   Brown     =  Table with 3 columns and 1 row:\u2026\n   Smith     =  Table with 3 columns and 3 rows:\u2026  The results are only summarized above (for compactness), but can be easily accessed.  julia  families[ Smith ]\nTable with 3 columns and 3 rows:\n     firstname  lastname  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice      Smith     25\n 2 \u2502 Bob        Smith     42\n 3 \u2502 Charlie    Smith     37  There are also more advanced functions  groupreduce ,  groupinds  and  groupview , which may help you perform your analysis more succinctly and faster, and are covered in later sections of this manual.", 
            "title": "Grouping data"
        }, 
        {
            "location": "/man/tutorial/#joining-data", 
            "text": "A very common relational operation is to  join  the data from two tables based on certain commonalities, such as the values matching in two columns.  SplitApplyCombine.jl  provides an  innerjoin  function for precisely this (please note that  join  is a Julia operation to concatenate strings).  Let's suppose we have a small database of customers, and the items they have ordered from an online store.  julia  customers = Table(id = 1:3, name = [ Alice ,  Bob ,  Charlie ], address = [ 12 Beach Street ,  163 Moon Road ,  6 George Street ])\nTable with 3 columns and 3 rows:\n     id  name     address\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 1   Alice    12 Beach Street\n 2 \u2502 2   Bob      163 Moon Road\n 3 \u2502 3   Charlie  6 George Street\n\njulia  orders = Table(customer_id = [2, 2, 3, 3], items = [ Socks ,  Tie ,  Shirt ,  Underwear ])\nTable with 2 columns and 4 rows:\n     customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2            Socks\n 2 \u2502 2            Tie\n 3 \u2502 3            Shirt\n 4 \u2502 3            Underwear  Here, these two tables are related by the customer's  id . We can join the two tables on this column to determine the  address  that we need to send the  items  to. The  innerjoin  function expects two functions, to describe the joining key of the first table and the joining key of the second table. We will use  getproperty  to select the columns.  julia  innerjoin(@Compute($id), @Compute($customer_id), customers, orders)\nTable with 5 columns and 4 rows:\n     id  name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2   Bob      163 Moon Road    2            Socks\n 2 \u2502 2   Bob      163 Moon Road    2            Tie\n 3 \u2502 3   Charlie  6 George Street  3            Shirt\n 4 \u2502 3   Charlie  6 George Street  3            Underwear  By default,  innerjoin  will  merge  all of the columns. Like  group , the  innerjoin  function can accept an additional function to describe a mapping to desired output (as well as a comparison operation on the keys). The more advanced features of  innerjoin  and other types of joins are covered in later sections of this manual.", 
            "title": "Joining data"
        }, 
        {
            "location": "/man/tutorial/#progressing-onwards", 
            "text": "Congratulations on completing the introductory tutorial. You should now know enough basics to get started with data analysis in Julia using  TypedTables.jl  and related packages.  The following setions of the manual demonstrate more advanced techniques, explain the  design of this (and related) packages, and provide an API reference.", 
            "title": "Progressing onwards"
        }, 
        {
            "location": "/man/table/", 
            "text": "Table\n\n\nIt's simple to get started and create a table!\n\n\njulia\n using TypedTables\n\njulia\n t = Table(a = [1, 2, 3], b = [2.0, 4.0, 6.0])\nTable with 2 columns and 3 rows:\n     a  b\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 1  2.0\n 2 \u2502 2  4.0\n 3 \u2502 3  6.0\n\njulia\n t[1]  # Get first row\n(a = 1, b = 2.0)\n\njulia\n t.a  # Get column `a`\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n\nWhat is a \nTable\n?\n\n\nTable is actually a Julia array type, where each element (row) is a \nNamedTuple\n. In particular:\n\n\n\n\nExternally. a \nTable\n presents itself as an array of named tuples. That is, each row of the table is represented as one of Julia's new \nNamedTuple\ns, which are easy to use and highly efficient. In subtype notation, \nTable \n: AbstractArray{\n:NamedTuple}\n.\n\n\nInternally, a \nTable\n stores a (named) tuple of arrays, and is a convenient structure for column-based storage of tabular data.\n\n\n\n\nThus, manipulating data as a \nTable\n is as easy as manipulating arrays and named tuples - which is something Julia was specifically designed to make simple, efficient and \nfun\n. \n\n\nTable\ns (and their columns) may be an \nAbstractArray\n of any dimensionality. This lets you take advantage of Julia's powerful array functionality, such as multidimensional broadcasting. Each column must be an array of the same dimensionality and size of the other columns.\n\n\n\n\nWhy use a \nTable\n?\n\n\nTwo words: productivity and speed.\n\n\nTypedTables.jl\n aims to introduce very few concepts, with minimal learning curve to let you manipulate tabular data. The \nTable\n type is a simple wrapper over columns and presents the well-known and extremely productive \nAbstractArray\n interface. If you are familiar with arrays and named tuples, you should be able to write your data analytics with a \nTable\n.\n\n\nHowever, it would be of little use if the data container was inherently slow, or if using the container was subject to traps and pitfalls where performance falls of a cliff if the programmer uses an otherwise-idiomatic pattern. In this case, \nfor\n loops over the rows of a \nTable\n are possible at the speed of hand-written code in a statically compiled language such as C, because the compiler is fully aware of the types of each column. Thus, users can write generic functions using a mixture of hand-written loops, calls to functions such as \nmap\n, \nfilter\n, \nreduce\n, \ngroup\n and \ninnerjoin\n, as well as high-level interfaces provided by packages such as \nQuery.jl\n - and still obtain optimal performance.\n\n\nFinally, since \nTable\n is unoppinionated about the underlying array storage (and acts more as a convenient metaprogramming layer), the arrays represent each column might have rather distinct properties - for example, supporting in-memory, out-of-core and distributed workloads (see the section on \nData Representation\n for more details).\n\n\n\n\nCreating \nTable\ns\n\n\nThe easiest way to create a table from columns is with keyword arguments, such as\n\n\njulia\n t = Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\n\n\n\nThe constructor will equally accept a \nNamedTuple\n of columns, as \nTable((name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37]))\n (note the extra brackets).\n\n\nAlso, one can easily convert the row-storage-based vector of named tuples into columnar storage using the \nTable\n constructor:\n\n\njulia\n Table([(name = \nAlice\n, age = 25), (name = \nBob\n, age = 42), (name = \nCharlie\n, age = 37)])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\n\n\n\n\n\nAccessing data stored in \nTable\ns\n\n\n\n\nRow access\n\n\nA single row of a \nTable\n is just a \nNamedTuple\n, which is easy to access.\n\n\njulia\n t[1]\n(name = \nAlice\n, age = 25)\n\n\n\n\nMultiple rows can be indexed similarly to standard arrays in Julia:\n\n\njulia\n t[2:3]\nTable with 2 columns and 2 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob      42\n 2 \u2502 Charlie  37\n\n\n\n\nOne can interrogate the \nlength\n, \nsize\n or \naxes\n of a \nTable\n just like any other \nAbstractArray\n:\n\n\njulia\n length(t)\n3\n\njulia\n size(t)\n(3,)\n\n\n\n\n(Note: the number of columns does not participate in the \nsize\n.)\n\n\nFinally, if the backing arrays support mutation, rows can be mutated with \nsetindex!\n\n\njulia\n t[3] = (name = Charlie, name = 38)  # Charlie had a birthday\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  38\n\n\n\n\nSimilarly, rows can be added or removed with \npush!\n, \npop!\n and \nso-on\n.\n\n\n\n\nColumn access\n\n\nA single column can be recovered using Julia's new \ngetproperty\n syntax using the \n.\n operator.\n\n\njulia\n t.name\n3-element Array{String,1}:\n \nAlice\n  \n \nBob\n    \n \nCharlie\n\n\n\n\n\nCurrently, the simplest way to extract more than one column is to construct a brand new table out of the columns (as in \ntable2 = Table(column1 = table1.column1, column2 = table1.column2, ...)\n).\n\n\nThe columns of a \nTable\n can be accessed directly as a \nNamedTuple\n of arrays using the \ncolumns\n function.\n\n\njulia\n columns(t)\n(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\n\n\n\n\nThere is a \ncolumnnames\n function for getting the names of the columns:\n\n\njulia\n columnnames(t)\n(:name, :age)\n\n\n\n\nNote that the column names are Julia \nSymbol\ns, which are \ninterned strings\n tracked by the compiler.\n\n\nFinally, the values contained in entire columns may be updated using \n.=\n, such as \nt.age .= 0\n or \nt.age .= [26, 43, 38]\n. Note that skipping the \n.\n in \n.=\n, such as \nt.age = [26, 43, 38]\n, will produce an error because the references to the column \ncontainers\n are immutable (if you wish to replace the entire \ncontainer\n of a column, you may need to use a \nFlexTable\n).\n\n\n\n\nCell access\n\n\nFrom the above, we can see two identical ways to get a cell of data:\n\n\njulia\n t[1].name\n\nAlice\n\n\njulia\n t.name[1]\n\nAlice\n\n\n\n\n\nWhile Julia's compiler will elide a lot of unnecessary code, you may find it faster to index individual cells of the table using the second option (to avoid fetching and constructing the \nentire\n named tuple of a row as an intermediate step).\n\n\nSimilarly, the value of a cell can be updated via \nsetindex!\n, for example using the syntax \nt.name[1] = \"Alicia\"\n. Note that the syntax \nt[1].name = \"Alicia\"\n will error because you are trying to mutate \nt[1]\n, which is an immutable \ncopy\n of the row (completely independent from \nt\n).\n\n\n\n\nComparison with other packages\n\n\n\n\nDataFrame\n\n\nFor those with experience using the \nDataFrames.jl\n package, this comparison may be useful:\n\n\n\n\nThe columns stored in a \nTable\n are immutable - you cannot add, remove or rename a column. However, it is very cheap to create a new table with different columns, encouraging a functional programming style to deal with your outer data structure. (See also \nFlexTable\n for a more flexible alternative). For comparison, this is a similar approach to \nIndexedTables\n and \nJuliaDB\n, while \nDataFrames\n uses an untyped vector of columns.\n\n\nThe columns themselves may be mutable. You may modify the data in one-or-more columns, and add or remove rows as necessary. Thus, operations on the \ndata\n (not the data \nstructure\n) can follow an imperative form, if desired.\n\n\nThe types of the columns are known to the compiler, making direct operations like iteration of the rows of a \nTable\n very fast. The programmer is free to write a combination of low-level \nfor\n loops, use operations like \nmap\n, \nfilter\n, \nreduce\n, \ngroup\n or \ninnerjoin\n, or to use a high-level query interface such as \nQuery.jl\n - all with the high performance you would expect of a statically compiled language.\n\n\nConversely, the Julia compiler spends effort tracking the names and types of all the columns of the table. If you have a very large number of columns (many hundreds), \nTable\n may not be a suitable data structure (here, \nDataFrame\ns dynamically sized and typed vector of columns may be more appropriate).\n\n\nTable\ns can be an array of any dimensionality.\n\n\nUnlike a \nDataFrame\n, you cannot access a single cell in a single \ngetindex\n call (you should first extract a column, and index a cell from that column). Similarly, the number of columns does not participate in the \nsize\n or \nlength\n of a \nTable\n.\n\n\n\n\nA good litimus test of whether a statically-compiled \nTable\n or a dynamic approach like \nDataFrames\n is more appropriate, is to see whether the written \ncode\n tends to refer to the columns by name, or whether the column names are more dynamic (and, for example, iteration over columns is required).", 
            "title": "Table"
        }, 
        {
            "location": "/man/table/#table", 
            "text": "It's simple to get started and create a table!  julia  using TypedTables\n\njulia  t = Table(a = [1, 2, 3], b = [2.0, 4.0, 6.0])\nTable with 2 columns and 3 rows:\n     a  b\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 1  2.0\n 2 \u2502 2  4.0\n 3 \u2502 3  6.0\n\njulia  t[1]  # Get first row\n(a = 1, b = 2.0)\n\njulia  t.a  # Get column `a`\n3-element Array{Int64,1}:\n 1\n 2\n 3", 
            "title": "Table"
        }, 
        {
            "location": "/man/table/#what-is-a-table", 
            "text": "Table is actually a Julia array type, where each element (row) is a  NamedTuple . In particular:   Externally. a  Table  presents itself as an array of named tuples. That is, each row of the table is represented as one of Julia's new  NamedTuple s, which are easy to use and highly efficient. In subtype notation,  Table  : AbstractArray{ :NamedTuple} .  Internally, a  Table  stores a (named) tuple of arrays, and is a convenient structure for column-based storage of tabular data.   Thus, manipulating data as a  Table  is as easy as manipulating arrays and named tuples - which is something Julia was specifically designed to make simple, efficient and  fun .   Table s (and their columns) may be an  AbstractArray  of any dimensionality. This lets you take advantage of Julia's powerful array functionality, such as multidimensional broadcasting. Each column must be an array of the same dimensionality and size of the other columns.", 
            "title": "What is a Table?"
        }, 
        {
            "location": "/man/table/#why-use-a-table", 
            "text": "Two words: productivity and speed.  TypedTables.jl  aims to introduce very few concepts, with minimal learning curve to let you manipulate tabular data. The  Table  type is a simple wrapper over columns and presents the well-known and extremely productive  AbstractArray  interface. If you are familiar with arrays and named tuples, you should be able to write your data analytics with a  Table .  However, it would be of little use if the data container was inherently slow, or if using the container was subject to traps and pitfalls where performance falls of a cliff if the programmer uses an otherwise-idiomatic pattern. In this case,  for  loops over the rows of a  Table  are possible at the speed of hand-written code in a statically compiled language such as C, because the compiler is fully aware of the types of each column. Thus, users can write generic functions using a mixture of hand-written loops, calls to functions such as  map ,  filter ,  reduce ,  group  and  innerjoin , as well as high-level interfaces provided by packages such as  Query.jl  - and still obtain optimal performance.  Finally, since  Table  is unoppinionated about the underlying array storage (and acts more as a convenient metaprogramming layer), the arrays represent each column might have rather distinct properties - for example, supporting in-memory, out-of-core and distributed workloads (see the section on  Data Representation  for more details).", 
            "title": "Why use a Table?"
        }, 
        {
            "location": "/man/table/#creating-tables", 
            "text": "The easiest way to create a table from columns is with keyword arguments, such as  julia  t = Table(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37  The constructor will equally accept a  NamedTuple  of columns, as  Table((name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37]))  (note the extra brackets).  Also, one can easily convert the row-storage-based vector of named tuples into columnar storage using the  Table  constructor:  julia  Table([(name =  Alice , age = 25), (name =  Bob , age = 42), (name =  Charlie , age = 37)])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37", 
            "title": "Creating Tables"
        }, 
        {
            "location": "/man/table/#accessing-data-stored-in-tables", 
            "text": "", 
            "title": "Accessing data stored in Tables"
        }, 
        {
            "location": "/man/table/#row-access", 
            "text": "A single row of a  Table  is just a  NamedTuple , which is easy to access.  julia  t[1]\n(name =  Alice , age = 25)  Multiple rows can be indexed similarly to standard arrays in Julia:  julia  t[2:3]\nTable with 2 columns and 2 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob      42\n 2 \u2502 Charlie  37  One can interrogate the  length ,  size  or  axes  of a  Table  just like any other  AbstractArray :  julia  length(t)\n3\n\njulia  size(t)\n(3,)  (Note: the number of columns does not participate in the  size .)  Finally, if the backing arrays support mutation, rows can be mutated with  setindex!  julia  t[3] = (name = Charlie, name = 38)  # Charlie had a birthday\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  38  Similarly, rows can be added or removed with  push! ,  pop!  and  so-on .", 
            "title": "Row access"
        }, 
        {
            "location": "/man/table/#column-access", 
            "text": "A single column can be recovered using Julia's new  getproperty  syntax using the  .  operator.  julia  t.name\n3-element Array{String,1}:\n  Alice   \n  Bob     \n  Charlie   Currently, the simplest way to extract more than one column is to construct a brand new table out of the columns (as in  table2 = Table(column1 = table1.column1, column2 = table1.column2, ...) ).  The columns of a  Table  can be accessed directly as a  NamedTuple  of arrays using the  columns  function.  julia  columns(t)\n(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])  There is a  columnnames  function for getting the names of the columns:  julia  columnnames(t)\n(:name, :age)  Note that the column names are Julia  Symbol s, which are  interned strings  tracked by the compiler.  Finally, the values contained in entire columns may be updated using  .= , such as  t.age .= 0  or  t.age .= [26, 43, 38] . Note that skipping the  .  in  .= , such as  t.age = [26, 43, 38] , will produce an error because the references to the column  containers  are immutable (if you wish to replace the entire  container  of a column, you may need to use a  FlexTable ).", 
            "title": "Column access"
        }, 
        {
            "location": "/man/table/#cell-access", 
            "text": "From the above, we can see two identical ways to get a cell of data:  julia  t[1].name Alice \n\njulia  t.name[1] Alice   While Julia's compiler will elide a lot of unnecessary code, you may find it faster to index individual cells of the table using the second option (to avoid fetching and constructing the  entire  named tuple of a row as an intermediate step).  Similarly, the value of a cell can be updated via  setindex! , for example using the syntax  t.name[1] = \"Alicia\" . Note that the syntax  t[1].name = \"Alicia\"  will error because you are trying to mutate  t[1] , which is an immutable  copy  of the row (completely independent from  t ).", 
            "title": "Cell access"
        }, 
        {
            "location": "/man/table/#comparison-with-other-packages", 
            "text": "", 
            "title": "Comparison with other packages"
        }, 
        {
            "location": "/man/table/#dataframe", 
            "text": "For those with experience using the  DataFrames.jl  package, this comparison may be useful:   The columns stored in a  Table  are immutable - you cannot add, remove or rename a column. However, it is very cheap to create a new table with different columns, encouraging a functional programming style to deal with your outer data structure. (See also  FlexTable  for a more flexible alternative). For comparison, this is a similar approach to  IndexedTables  and  JuliaDB , while  DataFrames  uses an untyped vector of columns.  The columns themselves may be mutable. You may modify the data in one-or-more columns, and add or remove rows as necessary. Thus, operations on the  data  (not the data  structure ) can follow an imperative form, if desired.  The types of the columns are known to the compiler, making direct operations like iteration of the rows of a  Table  very fast. The programmer is free to write a combination of low-level  for  loops, use operations like  map ,  filter ,  reduce ,  group  or  innerjoin , or to use a high-level query interface such as  Query.jl  - all with the high performance you would expect of a statically compiled language.  Conversely, the Julia compiler spends effort tracking the names and types of all the columns of the table. If you have a very large number of columns (many hundreds),  Table  may not be a suitable data structure (here,  DataFrame s dynamically sized and typed vector of columns may be more appropriate).  Table s can be an array of any dimensionality.  Unlike a  DataFrame , you cannot access a single cell in a single  getindex  call (you should first extract a column, and index a cell from that column). Similarly, the number of columns does not participate in the  size  or  length  of a  Table .   A good litimus test of whether a statically-compiled  Table  or a dynamic approach like  DataFrames  is more appropriate, is to see whether the written  code  tends to refer to the columns by name, or whether the column names are more dynamic (and, for example, iteration over columns is required).", 
            "title": "DataFrame"
        }, 
        {
            "location": "/man/flextable/", 
            "text": "FlexTable\n\n\nThis package defines a second tabular container type, \nFlexTable\n, that is designed to be a more \nflex\nible \ntable\n.\n\n\nThe two primary difference between \nTable\n and \nFlexTable\n are that\n\n\n\n\nThe columns can be mutated - that is, we can add, replace or delete a column.\n\n\nThe compiler cannot track the types or names of the columns.\n\n\n\n\nThus, a \nFlexTable\n provides the same interface as a \nTable\n plus some extra operations. However, the fact that the compiler can no longer statically analyse the names and types of the columns at any given moment of the program means that the element type of a \nFlexTable\n is no more specific than \nNamedTuple\n. Iteration over rows will therefore be slower using \nfor\n loops than for the equivalent \nTable\n - for maximum speed, higher-level functions (like \nmap\n, \nfilter\n, \nreduce\n, \ngroup\n and \ninnerjoin\n) or a high-level DSL (like \nQuery.jl\n) should be utilized.\n\n\nAmongst other things, using \nFlexTable\n might allow you to more easily port your code from another environment where the columns are mutable, such as \nDataFrames.jl\n.\n\n\n\n\nAdding or replacing columns\n\n\nA column can be added by using the \n.\n operator (also known as \nsetproperty!\n).\n\n\njulia\n ft = FlexTable(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nFlexTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia\n ft.sex = [:F, :M, :M];\n\njulia\n ft\nFlexTable with 3 columns and 3 rows:\n     name     age  sex\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25   F\n 2 \u2502 Bob      42   M\n 3 \u2502 Charlie  37   M\n\n\n\n\nThe same syntax is used to replace a column.\n\n\njulia\n ft.sex = [\nfemale\n, \nmale\n, \nmale\n];\n\njulia\n ft\nFlexTable with 3 columns and 3 rows:\n     name     age  sex\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25   female\n 2 \u2502 Bob      42   male\n 3 \u2502 Charlie  37   male", 
            "title": "FlexTable"
        }, 
        {
            "location": "/man/flextable/#flextable", 
            "text": "This package defines a second tabular container type,  FlexTable , that is designed to be a more  flex ible  table .  The two primary difference between  Table  and  FlexTable  are that   The columns can be mutated - that is, we can add, replace or delete a column.  The compiler cannot track the types or names of the columns.   Thus, a  FlexTable  provides the same interface as a  Table  plus some extra operations. However, the fact that the compiler can no longer statically analyse the names and types of the columns at any given moment of the program means that the element type of a  FlexTable  is no more specific than  NamedTuple . Iteration over rows will therefore be slower using  for  loops than for the equivalent  Table  - for maximum speed, higher-level functions (like  map ,  filter ,  reduce ,  group  and  innerjoin ) or a high-level DSL (like  Query.jl ) should be utilized.  Amongst other things, using  FlexTable  might allow you to more easily port your code from another environment where the columns are mutable, such as  DataFrames.jl .", 
            "title": "FlexTable"
        }, 
        {
            "location": "/man/flextable/#adding-or-replacing-columns", 
            "text": "A column can be added by using the  .  operator (also known as  setproperty! ).  julia  ft = FlexTable(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nFlexTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia  ft.sex = [:F, :M, :M];\n\njulia  ft\nFlexTable with 3 columns and 3 rows:\n     name     age  sex\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25   F\n 2 \u2502 Bob      42   M\n 3 \u2502 Charlie  37   M  The same syntax is used to replace a column.  julia  ft.sex = [ female ,  male ,  male ];\n\njulia  ft\nFlexTable with 3 columns and 3 rows:\n     name     age  sex\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25   female\n 2 \u2502 Bob      42   male\n 3 \u2502 Charlie  37   male", 
            "title": "Adding or replacing columns"
        }, 
        {
            "location": "/man/data/", 
            "text": "Data representation\n\n\nTypedTables\n leaves the user fully in charge of how they represent and store their data. The only requirements are that each column is an \nAbstractArray\n, all the columns have matching sizes, and that each column name is distinct.\n\n\nThis section contains some basic advice on how to choose what arrays to use to represent your data, depending on your needs.\n\n\n\n\nElement types and \nmissing\n data\n\n\nEach column is an \nAbstractArray{T}\n, where \nT\n is the \neltype\n (element type) of the array. Most frequently, this will be a \nVector{T}\n, where \nVector\n is a one-dimensional \nArray\n, unless you have special requirements.\n\n\nIn general, you should try to chose \nT\n to be a \nconcrete\n type, such as \nInt\n, \nFloat64\n, or \nString\n. Julia's compiler will know in advance how a concrete type is laid out in memory, and what function methods to dispatch to, allowing it to produce highly optimized machine code similar to hand-written C code.\n\n\nSometimes you may want to have more than one type of data in a column. One very convenient use case for this is to handle missing data. Julia 1.0 contains a value called \nmissing\n of a type called \nMissing\n . Many functions are defined for missing, such as \n1 + missing = missing\n and so-on, so the \"missingness\" of the data propagates correctly through even extremely complex calculations. The \nunion\n type \nUnion{T, Missing}\n is the officially recommended way to represent data which may be of type \nT\n or otherwise \nMissing\n. For example, a column which contains \noptional\n \nFloat64\n values may be best represent by a \nVector{Union{Float64, Missing}}\n. Union types are treated specially be the compiler, where it takes advantage of the fact that the value can only be of one of a small number of known types.\n\n\nIf your column may contain any of a variety of Julia types, it may be suitable to use \nabstract\n types like \nAny\n. You will be able to insert any element into a \nVector{Any}\n, but Julia will have to dynamically deal with the type of each element, slowing down run-time performance. This is a trade-off - using abstract types may allow the programmer to worry less about the details, at the cost of execution speed.\n\n\n\n\nArray types\n\n\nAs mentioned, each column is an \nAbstractArray\n, but there are many different \nconcrete\n implementations of the \nAbstractArray\n interface. The \nAbstractArray\n interface can be implemented by any type that has a \nsize\n and supports random access via \ngetindex\n - the syntax \narray[index]\n - and thus is extremely flexible, yet powerful.\n\n\nArray\n (and \nVector\n) is the prototypical \nAbstractArray\n, which provides random access to a flat array of memory. It is the type created by array-literal syntax, such as \n[1, 2, 3]\n. You can create an array of a given element type by prepending the type - for example, \nFloat64[1, 2, 3]\n is equivalent to \n[1.0, 2.0, 3.0]\n. You can create an empty vector of a given type \nT\n with \nT[]\n or the explicit constructor \nVector{T}()\n. If you want to be able to add missing values later, you may want to create an empty array with \nUnion{Float64, Missing}[]\n or \nVector{Union{Float64, Missing}}()\n.\n\n\nArray\ns are sufficient for playing with a relatively small amount of data at the REPL. However, \nTypedTables\n will let you use any of a wide variety of array types, depending on your needs. A few examples include:\n\n\n\n\nTypical \nArray\n-based columns represent continugous chunks of memory, and can be \nmemory-mapped\n from files on disk for a simple way of doing out-of-core analytics.\n\n\nAcceleration indices can be attached to columns using the \nAcceleratedArrays\n package, speeding up searches and joins.\n\n\nSome data can be stored in compressed form using \nsparse arrays\n, \ncategorical arrays\n, and so-on. Ranges such as \n1:length(table)\n are a compact way of including things like the table's primary key/indices as an explicit column.\n\n\nColumns could be stored and processed on a GPU with \nGPU-backed array\n using \nCUDA\n, \nOpenCL\n, \nArrayFire\n, etc.\n\n\nColumns might be distributed and processed in parallel over multiple machines with \nDistributedArrays\n or between multiple processes with \nSharedArrays\n.\n\n\nIn extreme cases, tables with a small, fixed number of rows might be most efficient represented with a \nstatically sized array\n.\n\n\n\n\nIn each case, the user will be able to use much the same interface (and code) to perform their transformations. In the background, Julia's compiler will create specialized, performant machine code, for whichever backing array you choose. You may be able to scale your calculations from rapid experimentation to large-scale production via a few simple changes to your array types.", 
            "title": "Data representation"
        }, 
        {
            "location": "/man/data/#data-representation", 
            "text": "TypedTables  leaves the user fully in charge of how they represent and store their data. The only requirements are that each column is an  AbstractArray , all the columns have matching sizes, and that each column name is distinct.  This section contains some basic advice on how to choose what arrays to use to represent your data, depending on your needs.", 
            "title": "Data representation"
        }, 
        {
            "location": "/man/data/#element-types-and-missing-data", 
            "text": "Each column is an  AbstractArray{T} , where  T  is the  eltype  (element type) of the array. Most frequently, this will be a  Vector{T} , where  Vector  is a one-dimensional  Array , unless you have special requirements.  In general, you should try to chose  T  to be a  concrete  type, such as  Int ,  Float64 , or  String . Julia's compiler will know in advance how a concrete type is laid out in memory, and what function methods to dispatch to, allowing it to produce highly optimized machine code similar to hand-written C code.  Sometimes you may want to have more than one type of data in a column. One very convenient use case for this is to handle missing data. Julia 1.0 contains a value called  missing  of a type called  Missing  . Many functions are defined for missing, such as  1 + missing = missing  and so-on, so the \"missingness\" of the data propagates correctly through even extremely complex calculations. The  union  type  Union{T, Missing}  is the officially recommended way to represent data which may be of type  T  or otherwise  Missing . For example, a column which contains  optional   Float64  values may be best represent by a  Vector{Union{Float64, Missing}} . Union types are treated specially be the compiler, where it takes advantage of the fact that the value can only be of one of a small number of known types.  If your column may contain any of a variety of Julia types, it may be suitable to use  abstract  types like  Any . You will be able to insert any element into a  Vector{Any} , but Julia will have to dynamically deal with the type of each element, slowing down run-time performance. This is a trade-off - using abstract types may allow the programmer to worry less about the details, at the cost of execution speed.", 
            "title": "Element types and missing data"
        }, 
        {
            "location": "/man/data/#array-types", 
            "text": "As mentioned, each column is an  AbstractArray , but there are many different  concrete  implementations of the  AbstractArray  interface. The  AbstractArray  interface can be implemented by any type that has a  size  and supports random access via  getindex  - the syntax  array[index]  - and thus is extremely flexible, yet powerful.  Array  (and  Vector ) is the prototypical  AbstractArray , which provides random access to a flat array of memory. It is the type created by array-literal syntax, such as  [1, 2, 3] . You can create an array of a given element type by prepending the type - for example,  Float64[1, 2, 3]  is equivalent to  [1.0, 2.0, 3.0] . You can create an empty vector of a given type  T  with  T[]  or the explicit constructor  Vector{T}() . If you want to be able to add missing values later, you may want to create an empty array with  Union{Float64, Missing}[]  or  Vector{Union{Float64, Missing}}() .  Array s are sufficient for playing with a relatively small amount of data at the REPL. However,  TypedTables  will let you use any of a wide variety of array types, depending on your needs. A few examples include:   Typical  Array -based columns represent continugous chunks of memory, and can be  memory-mapped  from files on disk for a simple way of doing out-of-core analytics.  Acceleration indices can be attached to columns using the  AcceleratedArrays  package, speeding up searches and joins.  Some data can be stored in compressed form using  sparse arrays ,  categorical arrays , and so-on. Ranges such as  1:length(table)  are a compact way of including things like the table's primary key/indices as an explicit column.  Columns could be stored and processed on a GPU with  GPU-backed array  using  CUDA ,  OpenCL ,  ArrayFire , etc.  Columns might be distributed and processed in parallel over multiple machines with  DistributedArrays  or between multiple processes with  SharedArrays .  In extreme cases, tables with a small, fixed number of rows might be most efficient represented with a  statically sized array .   In each case, the user will be able to use much the same interface (and code) to perform their transformations. In the background, Julia's compiler will create specialized, performant machine code, for whichever backing array you choose. You may be able to scale your calculations from rapid experimentation to large-scale production via a few simple changes to your array types.", 
            "title": "Array types"
        }, 
        {
            "location": "/man/io/", 
            "text": "Input and output\n\n\nInput and output of \nTable\n and \nFlexTable\n are mostly handled through externally-defined interfaces.\n\n\n\n\nAbstractArray interface\n\n\nOne can convert an \nAbstractArray\n of \nNamedTuple\ns to a \nTable\n using a simple constructor.\n\n\njulia\n v = [(name=\nAlice\n, age=25), (name=\nBob\n, age=42), (name= \nCharlie\n, age=37)]\n3-element Array{NamedTuple{(:name, :age),Tuple{String,Int64}},1}:\n (name = \nAlice\n, age = 25)  \n (name = \nBob\n, age = 42)    \n (name = \nCharlie\n, age = 37)\n\njulia\n t = Table(v)\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\n\n\n\nIn this way, we have converted a row-based storage container to a column-based storage container.\n\n\nOne can convert back to row-based storage by \ncollect\ning the results in an \nArray\n. \n\n\njulia\n collect(t)\n3-element Array{NamedTuple{(:name, :age),Tuple{String,Int64}},1}:\n (name = \nAlice\n, age = 25)  \n (name = \nBob\n, age = 42)    \n (name = \nCharlie\n, age = 37)\n\n\n\n\nNote that \ncollect\n is the generic construtor for an \nArray\n which accepts any kind of iterable - an \"iterable\" being any type that supports the \niterate\n function.\n\n\n\n\nTables.jl\n\n\nNOTE: The information in this section represents the development versions of \nTables\n, \nCSV\n and related packages.\n\n\nThe \nTables.jl\n package provides a flexible interface for dealing with tabular data of all forms: from in-memory \nTable\ns to \nCSV\n files on a disk.\n\n\nAt it's core, it provides a way of:\n\n\n\n\nIntrospecting data via \nTables.istable\n, \nTables.schema\n, and so-on.\n\n\nProvide a row iterator via \nrows(data)\n, where each row has fields/cells accessed by \ngetproperty\n.\n\n\nProvide a collection of columns via \ncolumns(data)\n that can be accessed via \ngetpropery\n, each of which iterates fields/cells.\n\n\n\n\nIt's simple design allows us to treat many forms of tabular data in the same way.\n\n\n\n\nCSV.jl\n\n\nAs an example of good use of the \nTables.jl\n, take the package \nCSV.jl\n, which is designed to load and save CSV files.\n\n\nLet's say we have a CSV file called \ninput.csv\n, and the following data.\n\n\nname,age\nAlice,25\nBob,42\nCharlie,37\n\n\n\n\nWe can load this file from disk using the \nCSV.File\n constructor.\n\n\njulia\n using TypedTables, CSV\n\njulia\n csvfile = CSV.File(\ninput.csv\n)\nCSV.File(\n/home/ferris/example.csv\n, rows=3):\nTables.Schema:\n :name  Union{Missing, String}\n :age   Union{Missing, Int64}\n\n\n\n\nNote that \nCSV\n has inferred the column types from the data, but by default allows for \nmissing\n data. This can be controlled via the \nallowmissing\n keyword argument (as either \n:all\n, \n:none\n or \n:auto\n).\n\n\njulia\n CSV.File(\ninput.csv\n, allowmissing=:none)\nCSV.File(\n/home/ferris/example.csv\n, rows=3):\nTables.Schema:\n :name  String\n :age   Int64 \n\n\n\n\nEither of these can finally be converted to a \nTable\n.\n\n\njulia\n Table(csvfile)\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\n\n\n\nSimilarly, the \nCSV.jl\n package supports writing tables with  \nCSV.write\n function.\n\n\njulia\n CSV.write(\noutput.csv\n, t)\n\noutput.csv", 
            "title": "Input and output"
        }, 
        {
            "location": "/man/io/#input-and-output", 
            "text": "Input and output of  Table  and  FlexTable  are mostly handled through externally-defined interfaces.", 
            "title": "Input and output"
        }, 
        {
            "location": "/man/io/#abstractarray-interface", 
            "text": "One can convert an  AbstractArray  of  NamedTuple s to a  Table  using a simple constructor.  julia  v = [(name= Alice , age=25), (name= Bob , age=42), (name=  Charlie , age=37)]\n3-element Array{NamedTuple{(:name, :age),Tuple{String,Int64}},1}:\n (name =  Alice , age = 25)  \n (name =  Bob , age = 42)    \n (name =  Charlie , age = 37)\n\njulia  t = Table(v)\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37  In this way, we have converted a row-based storage container to a column-based storage container.  One can convert back to row-based storage by  collect ing the results in an  Array .   julia  collect(t)\n3-element Array{NamedTuple{(:name, :age),Tuple{String,Int64}},1}:\n (name =  Alice , age = 25)  \n (name =  Bob , age = 42)    \n (name =  Charlie , age = 37)  Note that  collect  is the generic construtor for an  Array  which accepts any kind of iterable - an \"iterable\" being any type that supports the  iterate  function.", 
            "title": "AbstractArray interface"
        }, 
        {
            "location": "/man/io/#tablesjl", 
            "text": "NOTE: The information in this section represents the development versions of  Tables ,  CSV  and related packages.  The  Tables.jl  package provides a flexible interface for dealing with tabular data of all forms: from in-memory  Table s to  CSV  files on a disk.  At it's core, it provides a way of:   Introspecting data via  Tables.istable ,  Tables.schema , and so-on.  Provide a row iterator via  rows(data) , where each row has fields/cells accessed by  getproperty .  Provide a collection of columns via  columns(data)  that can be accessed via  getpropery , each of which iterates fields/cells.   It's simple design allows us to treat many forms of tabular data in the same way.", 
            "title": "Tables.jl"
        }, 
        {
            "location": "/man/io/#csvjl", 
            "text": "As an example of good use of the  Tables.jl , take the package  CSV.jl , which is designed to load and save CSV files.  Let's say we have a CSV file called  input.csv , and the following data.  name,age\nAlice,25\nBob,42\nCharlie,37  We can load this file from disk using the  CSV.File  constructor.  julia  using TypedTables, CSV\n\njulia  csvfile = CSV.File( input.csv )\nCSV.File( /home/ferris/example.csv , rows=3):\nTables.Schema:\n :name  Union{Missing, String}\n :age   Union{Missing, Int64}  Note that  CSV  has inferred the column types from the data, but by default allows for  missing  data. This can be controlled via the  allowmissing  keyword argument (as either  :all ,  :none  or  :auto ).  julia  CSV.File( input.csv , allowmissing=:none)\nCSV.File( /home/ferris/example.csv , rows=3):\nTables.Schema:\n :name  String\n :age   Int64   Either of these can finally be converted to a  Table .  julia  Table(csvfile)\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37  Similarly, the  CSV.jl  package supports writing tables with   CSV.write  function.  julia  CSV.write( output.csv , t) output.csv", 
            "title": "CSV.jl"
        }, 
        {
            "location": "/man/map/", 
            "text": "Mapping rows of data\n\n\nSome operations on your data will act by mapping each row of data in a table to a value, or even to new rows (in the case of relational operations). In either case, you are mapping an element of table (which is an array whose elements are rows) to create a new array of computed elements (whose elements may or may not be rows, and thus may or may not be a \nTable\n).\n\n\n\n\nUsing \nmap\n\n\nIn Julia, the idiomatic way to perform such an operation is with the \nmap\n function, which takes a function and an input array.\n\n\nOne very simple example of this is extracting a column, let's say the column called \nname\n from a table of people's names and ages.\n\n\njulia\n t = Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia\n map(row -\n row.name, t)\n3-element Array{String,1}:\n \nAlice\n  \n \nBob\n    \n \nCharlie\n\n\n\n\n\nThis has returned and standard Julia array, which will be a \ncopy\n of the array of the \nname\n column. We could also do a more complicated calculation.\n\n\njulia\n is_old = map(row -\n row.age \n 40, t)\n3-element Array{Bool,1}:\n false\n  true\n false\n\n\n\n\nDepending on your definition of \"old\", we have identified two younger people and one older person - though I suspect that Bob may have a different definition of old than Alice does.\n\n\nOne can also \nmap\n rows, which are \nNamedTuple\ns, to new \nNamedTuples\n, which will naturally result in a new tabular structure. Here is an example where we simply copy the names into a new table (but change the column name to \nfirstname\n):\n\n\njulia\n map(row -\n (firstname = row.name,), t)\nTable with 1 column and 3 rows:\n     firstname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Bob\n 3 \u2502 Charlie\n\n\n\n\nInternally, this is leveraging Julia's \nsimilar\n interface for constructing new arrays: if we are creating something \nsimilar\n to a \nTable\n with an element type that is a \nNamedTuple\n, we get a new \nTable\n. (The columns themselves are also \nsimilar\n to the existing columns, preserving their structure as appropriate). If the output type is not a \nNamedTuple\n, the output array is \nsimilar\n to the first column.\n\n\nPutting this all together, we can create a brand-new table using \nmap\n to manipulate both columns.\n\n\njulia\n map(row -\n (name = row.name, is_old = row.age \n 40), t)\nTable with 2 columns and 3 rows:\n     name     is_old\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    false\n 2 \u2502 Bob      true\n 3 \u2502 Charlie  false\n\n\n\n\n\n\nExplicit \nfor\n loops\n\n\nOne can easily use \nfor\n loops to iterate over your data and perform whatever mapping is required. For example, this loop takes the \nfirst\n character of the elements of the \nname\n column.\n\n\njulia\n function firstletter(t::Table)\n    out = Vector{Char}(undef, length(t))\n\n    for i in 1:length(t)\n        out[i] = first(t.name[i])\n    end\n\n    return out\nend\n\njulia\n firstletter(t)\n3-element Array{Char,1}:\n 'A'\n 'B'\n 'C'\n\n\n\n\nJulia will use the type information it knows about \nt\n to create fast, compiled code. (Pro tip: to make the above loop \noptimal\n, adding an \n@inbounds\n annotation on the same line before the \nfor\n loop will remove redundant array bounds checking and make the loop execute faster).\n\n\n\n\nGenerators\n\n\nJulia syntax provide for compact syntax for generators and comprehensions to define arrays.\n\n\n\n\nThe syntax \n[f(x) for x in y]\n is called a \"comprehension\" and constructs a new \nArray\n.\n\n\nThe syntax \nf(x) for x in y\n is called a \nGenerator\n and is a lazy, iterable container called \nBase.Generator\n.\n\n\n\n\nTables can be constructed from \nGeneartor\ns, allowing for some pretty neat syntax.\n\n\njulia\n Table((name=row.name, isold=row.age\n40) for row in t)\nTable with 2 columns and 3 rows:\n     name     isold\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    false\n 2 \u2502 Bob      true\n 3 \u2502 Charlie  false\n\n\n\n\nGenerators and comprehensions also support filtering data and combining multiple datasets, which cover in \nFinding Data\n and \nJoining Data\n.\n\n\n\n\nPreselection\n\n\nFunctions like \nmap\n are not necessarily very intelligent about which columns are required and which are not. The reason is simple: given the operation \nmap(f, t)\n, the \nmap\n method has very little insight into what \nf\n does.\n\n\nThus, in some cases it might improve performance to preselect the columns of interest. For example, extracting a single column, or constructing a new table with a reduced number of columns, may prevent \nmap\n from loading unused values as it materializes each full row as it iterates, and lead to performance improvements.\n\n\n\n\ngetproperty\n and \nmap\n\n\nWhen we want to perform more complex tasks, such as \ngroup\n or \ninnerjoin\n, we may be interested in extracting data from specific columns.\n\n\nGiven a \nrow\n, a field is extracted with the \nrow.name\n syntax - which Julia transforms to the function call \ngetproperty(row, :name)\n. This package defines \ngetproperty(:name)\n as returning a new, single-argument \nfunction\n that takes a \nrow\n and returns \nrow.name\n.\n\n\nThus, one way of projecting a table down to a single column is to use the \ngetproperty\n function, like so:\n\n\njulia\n map(getproperty(:name), t)\n3-element Array{String,1}:\n \nAlice\n\n \nBob\n\n \nCharlie\n\n\n\n\n\nWhile this operation may seem pointless (it's a lot less direct than \nt.name\n, after all!), projecting to a single column will be a common operation for more complex tasks such as grouping data and performing relational joins.\n\n\nA naive implementation of this would be to iterate the rows and \nthen\n project down to just the column of interest. For efficiency, functions like \nmap\n (and \ngroup\n, \ninnerjoin\n, etc) will know they can first project a \nTable\n or \nFlexTable\n to just that column, before continuing - making the operations significantly faster.\n\n\n\n\nLazy mapping\n\n\nIt is also worth mentioning the possibility of lazily mapping the values. Functions such as \nmapview\n from \nSplitApplyCombine\n can let you construct a \"view\" of a new table based on existing data. This way you can avoid using up precious resources, like RAM, yet can still call up data upon demand.", 
            "title": "Mapping data"
        }, 
        {
            "location": "/man/map/#mapping-rows-of-data", 
            "text": "Some operations on your data will act by mapping each row of data in a table to a value, or even to new rows (in the case of relational operations). In either case, you are mapping an element of table (which is an array whose elements are rows) to create a new array of computed elements (whose elements may or may not be rows, and thus may or may not be a  Table ).", 
            "title": "Mapping rows of data"
        }, 
        {
            "location": "/man/map/#using-map", 
            "text": "In Julia, the idiomatic way to perform such an operation is with the  map  function, which takes a function and an input array.  One very simple example of this is extracting a column, let's say the column called  name  from a table of people's names and ages.  julia  t = Table(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia  map(row -  row.name, t)\n3-element Array{String,1}:\n  Alice   \n  Bob     \n  Charlie   This has returned and standard Julia array, which will be a  copy  of the array of the  name  column. We could also do a more complicated calculation.  julia  is_old = map(row -  row.age   40, t)\n3-element Array{Bool,1}:\n false\n  true\n false  Depending on your definition of \"old\", we have identified two younger people and one older person - though I suspect that Bob may have a different definition of old than Alice does.  One can also  map  rows, which are  NamedTuple s, to new  NamedTuples , which will naturally result in a new tabular structure. Here is an example where we simply copy the names into a new table (but change the column name to  firstname ):  julia  map(row -  (firstname = row.name,), t)\nTable with 1 column and 3 rows:\n     firstname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Bob\n 3 \u2502 Charlie  Internally, this is leveraging Julia's  similar  interface for constructing new arrays: if we are creating something  similar  to a  Table  with an element type that is a  NamedTuple , we get a new  Table . (The columns themselves are also  similar  to the existing columns, preserving their structure as appropriate). If the output type is not a  NamedTuple , the output array is  similar  to the first column.  Putting this all together, we can create a brand-new table using  map  to manipulate both columns.  julia  map(row -  (name = row.name, is_old = row.age   40), t)\nTable with 2 columns and 3 rows:\n     name     is_old\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    false\n 2 \u2502 Bob      true\n 3 \u2502 Charlie  false", 
            "title": "Using map"
        }, 
        {
            "location": "/man/map/#explicit-for-loops", 
            "text": "One can easily use  for  loops to iterate over your data and perform whatever mapping is required. For example, this loop takes the  first  character of the elements of the  name  column.  julia  function firstletter(t::Table)\n    out = Vector{Char}(undef, length(t))\n\n    for i in 1:length(t)\n        out[i] = first(t.name[i])\n    end\n\n    return out\nend\n\njulia  firstletter(t)\n3-element Array{Char,1}:\n 'A'\n 'B'\n 'C'  Julia will use the type information it knows about  t  to create fast, compiled code. (Pro tip: to make the above loop  optimal , adding an  @inbounds  annotation on the same line before the  for  loop will remove redundant array bounds checking and make the loop execute faster).", 
            "title": "Explicit for loops"
        }, 
        {
            "location": "/man/map/#generators", 
            "text": "Julia syntax provide for compact syntax for generators and comprehensions to define arrays.   The syntax  [f(x) for x in y]  is called a \"comprehension\" and constructs a new  Array .  The syntax  f(x) for x in y  is called a  Generator  and is a lazy, iterable container called  Base.Generator .   Tables can be constructed from  Geneartor s, allowing for some pretty neat syntax.  julia  Table((name=row.name, isold=row.age 40) for row in t)\nTable with 2 columns and 3 rows:\n     name     isold\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    false\n 2 \u2502 Bob      true\n 3 \u2502 Charlie  false  Generators and comprehensions also support filtering data and combining multiple datasets, which cover in  Finding Data  and  Joining Data .", 
            "title": "Generators"
        }, 
        {
            "location": "/man/map/#preselection", 
            "text": "Functions like  map  are not necessarily very intelligent about which columns are required and which are not. The reason is simple: given the operation  map(f, t) , the  map  method has very little insight into what  f  does.  Thus, in some cases it might improve performance to preselect the columns of interest. For example, extracting a single column, or constructing a new table with a reduced number of columns, may prevent  map  from loading unused values as it materializes each full row as it iterates, and lead to performance improvements.", 
            "title": "Preselection"
        }, 
        {
            "location": "/man/map/#getproperty-and-map", 
            "text": "When we want to perform more complex tasks, such as  group  or  innerjoin , we may be interested in extracting data from specific columns.  Given a  row , a field is extracted with the  row.name  syntax - which Julia transforms to the function call  getproperty(row, :name) . This package defines  getproperty(:name)  as returning a new, single-argument  function  that takes a  row  and returns  row.name .  Thus, one way of projecting a table down to a single column is to use the  getproperty  function, like so:  julia  map(getproperty(:name), t)\n3-element Array{String,1}:\n  Alice \n  Bob \n  Charlie   While this operation may seem pointless (it's a lot less direct than  t.name , after all!), projecting to a single column will be a common operation for more complex tasks such as grouping data and performing relational joins.  A naive implementation of this would be to iterate the rows and  then  project down to just the column of interest. For efficiency, functions like  map  (and  group ,  innerjoin , etc) will know they can first project a  Table  or  FlexTable  to just that column, before continuing - making the operations significantly faster.", 
            "title": "getproperty and map"
        }, 
        {
            "location": "/man/map/#lazy-mapping", 
            "text": "It is also worth mentioning the possibility of lazily mapping the values. Functions such as  mapview  from  SplitApplyCombine  can let you construct a \"view\" of a new table based on existing data. This way you can avoid using up precious resources, like RAM, yet can still call up data upon demand.", 
            "title": "Lazy mapping"
        }, 
        {
            "location": "/man/filter/", 
            "text": "Finding data\n\n\nFrequently, we need to find data (i.e. rows of the table) that matches certain criteria, and there are multiple mechanisms for achieving this in Julia. Here we will briefly review \nmap\n, \nfindall\n and \nfilter\n as options.\n\n\n\n\nmap(predicate, table)\n\n\nFollowing the previous section, we can identify row satisfying an arbitrary predicate using the \nmap\n function. Note that \"predicate\" is just a name for function that takes an input and returns either \ntrue\n or \nfalse\n.\n\n\njulia\n t = Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia\n is_old = map(row -\n row.age \n 40, t)\n3-element Array{Bool,1}:\n false\n  true\n false\n\n\n\n\nFinally, we can use \"logical\" (i.e. Boolean) indexing to extract the rows where the predicate is \ntrue\n.\n\n\njulia\n t[is_old]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42\n\n\n\n\nThe \nmap(predicate, table)\n approach will allocate one \nBool\n for each row in the input table - for a total of \nlength(table)\n bytes. \nSplitApplyCombine\n defines a \nmapview\n function to do this lazily.\n\n\n\n\nfindall(predicate, table)\n\n\nIf we wish to locate the indices of the rows where the predicate returns \ntrue\n, we can use Julia's \nfindall\n function.\n\n\njulia\n inds = findall(row -\n row.age \n 40, t)\n1-element Array{Int64,1}:\n 2\n\njulia\n t[inds]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42\n\n\n\n\nThis method may be less resource intensive (result in less memory allocated) if you are expecting a small number of matching rows, returing one \nInt\n per result.\n\n\n\n\nfilter(predicate, table)\n\n\nFinally, if we wish to directly \nfilter\n the table and obtain the rows of interest, we can do that as well.\n\n\njulia\n filter(row -\n row.age \n 40, t)\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42\n\n\n\n\nInternally, the \nfilter\n method may rely on one of the implementations above.\n\n\n\n\nGenerators\n\n\nJulia's \"generator\" syntax also allows for filtering operations using \nif\n.\n\n\njulia\n Table(row for row in t if row.age \n 40)\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42\n\n\n\n\n\nThis can be combined with mapping at the same time, as in \nTable(f(row) for row in table if predicate(row))\n. In \nJoining Data\n we discuss how to use generator syntax to combine multiple datasets.\n\n\n\n\nPreselection\n\n\nAs mentioned in other sections, it is frequently worthwhile to preselect the columns relating to your search predicate, to avoid any wastage in fetching from memory values in columns that you don't care about.\n\n\nOne simple example of such a transformation is to first project to the column(s) of interest, followed by using \nmap\n or \nfindall\n to identify the indices of the rows where \npredicate\n is \ntrue\n, and finally to use \ngetindex\n or \nview\n to obtain the result of the full table.\n\n\njulia\n inds = findall(age -\n age \n 40, t.age)\n1-element Array{Int64,1}:\n 2\n\njulia\n t[inds]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42\n\n\n\n\nEasy, peasy!", 
            "title": "Finding data"
        }, 
        {
            "location": "/man/filter/#finding-data", 
            "text": "Frequently, we need to find data (i.e. rows of the table) that matches certain criteria, and there are multiple mechanisms for achieving this in Julia. Here we will briefly review  map ,  findall  and  filter  as options.", 
            "title": "Finding data"
        }, 
        {
            "location": "/man/filter/#mappredicate-table", 
            "text": "Following the previous section, we can identify row satisfying an arbitrary predicate using the  map  function. Note that \"predicate\" is just a name for function that takes an input and returns either  true  or  false .  julia  t = Table(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia  is_old = map(row -  row.age   40, t)\n3-element Array{Bool,1}:\n false\n  true\n false  Finally, we can use \"logical\" (i.e. Boolean) indexing to extract the rows where the predicate is  true .  julia  t[is_old]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42  The  map(predicate, table)  approach will allocate one  Bool  for each row in the input table - for a total of  length(table)  bytes.  SplitApplyCombine  defines a  mapview  function to do this lazily.", 
            "title": "map(predicate, table)"
        }, 
        {
            "location": "/man/filter/#findallpredicate-table", 
            "text": "If we wish to locate the indices of the rows where the predicate returns  true , we can use Julia's  findall  function.  julia  inds = findall(row -  row.age   40, t)\n1-element Array{Int64,1}:\n 2\n\njulia  t[inds]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42  This method may be less resource intensive (result in less memory allocated) if you are expecting a small number of matching rows, returing one  Int  per result.", 
            "title": "findall(predicate, table)"
        }, 
        {
            "location": "/man/filter/#filterpredicate-table", 
            "text": "Finally, if we wish to directly  filter  the table and obtain the rows of interest, we can do that as well.  julia  filter(row -  row.age   40, t)\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42  Internally, the  filter  method may rely on one of the implementations above.", 
            "title": "filter(predicate, table)"
        }, 
        {
            "location": "/man/filter/#generators", 
            "text": "Julia's \"generator\" syntax also allows for filtering operations using  if .  julia  Table(row for row in t if row.age   40)\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42  This can be combined with mapping at the same time, as in  Table(f(row) for row in table if predicate(row)) . In  Joining Data  we discuss how to use generator syntax to combine multiple datasets.", 
            "title": "Generators"
        }, 
        {
            "location": "/man/filter/#preselection", 
            "text": "As mentioned in other sections, it is frequently worthwhile to preselect the columns relating to your search predicate, to avoid any wastage in fetching from memory values in columns that you don't care about.  One simple example of such a transformation is to first project to the column(s) of interest, followed by using  map  or  findall  to identify the indices of the rows where  predicate  is  true , and finally to use  getindex  or  view  to obtain the result of the full table.  julia  inds = findall(age -  age   40, t.age)\n1-element Array{Int64,1}:\n 2\n\njulia  t[inds]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42  Easy, peasy!", 
            "title": "Preselection"
        }, 
        {
            "location": "/man/reduce/", 
            "text": "Reducing data\n\n\nHere we demonstrate how to ask a few questions with \"scalar\" answers - like \"Does the table contain \nx\n?\", or \"What is the average value of \ny\n?\"\n\n\n\n\nTesting containment\n\n\nOne of the most basic questions to ask is: \"Is this element in the table/column?\". Julia's \nin\n operator is perfect for this.\n\n\njulia\n t = Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia\n in(\nAlice\n, t.name)\ntrue\n\njulia\n in(\nDebbie\n, t.name)\nfalse\n\n\n\n\nThe \nin\n function can also be used as an infix operator, as in \n\"Alice\" in t.name\n or \n\"Alice\" \u2208 t.name\n.\n\n\n\n\n\"How many?\"\n\n\nThe \ncount\n method is useful for asking how many rows satisfy a certain criterion.\n\n\njulia\n count(row -\n row.age \n 40, t)\n1\n\n\n\n\n\n\nTotals, averages, etc.\n\n\nIndividual columns can be reduced in the typical way for Julia arrays. Some examples.\n\n\njulia\n sum(t.age)\n104\n\njulia\n using Statistics\n\njulia\n mean(t.age)\n34.666666666666664\n\njulia\n median(t.age)\n37.0\n\njulia\n join(t.name, \n, \n, \n and \n)\n\nAlice, Bob and Charlie\n\n\n\n\n\nNote that \njoin\n is a string joining function; see \ninnerjoin\n (from \nSplitApplyCombine\n) for the relational operation.\n\n\nIt's just as easy to calculate multi-column statistics by reducing over the entire table.\n\n\njulia\n mapreduce(row -\n length(row.name) * row.age, +, t)\n510", 
            "title": "Reducing data"
        }, 
        {
            "location": "/man/reduce/#reducing-data", 
            "text": "Here we demonstrate how to ask a few questions with \"scalar\" answers - like \"Does the table contain  x ?\", or \"What is the average value of  y ?\"", 
            "title": "Reducing data"
        }, 
        {
            "location": "/man/reduce/#testing-containment", 
            "text": "One of the most basic questions to ask is: \"Is this element in the table/column?\". Julia's  in  operator is perfect for this.  julia  t = Table(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia  in( Alice , t.name)\ntrue\n\njulia  in( Debbie , t.name)\nfalse  The  in  function can also be used as an infix operator, as in  \"Alice\" in t.name  or  \"Alice\" \u2208 t.name .", 
            "title": "Testing containment"
        }, 
        {
            "location": "/man/reduce/#how-many", 
            "text": "The  count  method is useful for asking how many rows satisfy a certain criterion.  julia  count(row -  row.age   40, t)\n1", 
            "title": "\"How many?\""
        }, 
        {
            "location": "/man/reduce/#totals-averages-etc", 
            "text": "Individual columns can be reduced in the typical way for Julia arrays. Some examples.  julia  sum(t.age)\n104\n\njulia  using Statistics\n\njulia  mean(t.age)\n34.666666666666664\n\njulia  median(t.age)\n37.0\n\njulia  join(t.name,  ,  ,   and  ) Alice, Bob and Charlie   Note that  join  is a string joining function; see  innerjoin  (from  SplitApplyCombine ) for the relational operation.  It's just as easy to calculate multi-column statistics by reducing over the entire table.  julia  mapreduce(row -  length(row.name) * row.age, +, t)\n510", 
            "title": "Totals, averages, etc."
        }, 
        {
            "location": "/man/group/", 
            "text": "Grouping data\n\n\nIt is frequently useful to break data appart into different \ngroups\n for processing - a paradigm frequently referred to a the split-apply-combine methodology.\n\n\nIn a powerful environment such as Julia, that fully supports nested containers, it makes sense to represent each group as distinct containers, with an outer container acting as a \"dictionary\" of the groups. This is in contrast to environments with a less rich system of containers, such as SQL, which has popularized a slightly different notion of grouping data into a single flat tabular structure, where one (or more) columns act as the grouping key. Here we focus on the former approach.\n\n\n\n\nUsing the \ngroup\n function\n\n\nSplitApplyCombine\n provides a \ngroup\n function, which can operate on arbitary Julia objects. The function has the signature \ngroup(by, f, iter)\n where \niter\n is a container that can be iterated, \nby\n is a function from the elements of \niter\n to the grouping \nkey\n, and the optional argument \nf\n is a mapping applied to the grouped elements (by default, \nf = identity\n, the identity function).\n\n\nTo demonstrate the power of grouping, this time we'll add some more rows and columns to our example data.\n\n\njulia\n t = Table(firstname = [\nAlice\n, \nBob\n, \nCharlie\n, \nAdam\n, \nEve\n, \nCindy\n, \nArthur\n], lastname = [\nSmith\n, \nSmith\n, \nSmith\n, \nWilliams\n, \nWilliams\n, \nBrown\n, \nKing\n], age = [25, 42, 37, 65, 18, 33, 54])\nTable with 3 columns and 7 rows:\n     firstname  lastname  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice      Smith     25\n 2 \u2502 Bob        Smith     42\n 3 \u2502 Charlie    Smith     37\n 4 \u2502 Adam       Williams  65\n 5 \u2502 Eve        Williams  18\n 6 \u2502 Cindy      Brown     33\n 7 \u2502 Arthur     King      54\n\n\n\n\nLet's get familiar with the \nbasic\n usage of \ngroup\n on standard (non-tabular) arrays. For example, let's group people's first name by their first letter.\n\n\njulia\n group(first, t.firstname)\nDict{Char,Array{String,1}} with 4 entries:\n  'C' =\n [\nCharlie\n, \nCindy\n]\n  'A' =\n [\nAlice\n, \nAdam\n, \nArthur\n]\n  'E' =\n [\nEve\n]\n  'B' =\n [\nBob\n]\n\n\n\n\nThe groups are returned as a \nDict\n where they indices (or keys) of the dictionary are the first character of people's firstname string. The values of the \nDict\n are arrays listing the matching firstnames.\n\n\nNext, we may want to group up data coming from a table (not just a single column). For example, we may want to group firstnames by lastname.\n\n\njulia\n group(getproperty(:lastname), getproperty(:firstname), t)\nDict{String,Array{String,1}} with 4 entries:\n  \nKing\n     =\n [\nArthur\n]\n  \nWilliams\n =\n [\nAdam\n, \nEve\n]\n  \nBrown\n    =\n [\nCindy\n]\n  \nSmith\n    =\n [\nAlice\n, \nBob\n, \nCharlie\n]\n\n\n\n\nNote that the returned structure is still not a \nTable\n at all - it is a dictionary (\nDict\n) with the unique \nlastname\n values as keys, returing (non-tabular) arrays of \nfirstname\n.\n\n\nIf instead, our grouping elements are \nrows\n, the group will be a table. For example, we can just drop the \ngetproperty(:firstname)\n projection to get:\n\n\njulia\n groups = group(getproperty(:lastname), t)\nGroups{String,Any,Table{NamedTuple{(:firstname, :lastname, :age),Tuple{String,String,Int64}},1,NamedTuple{(:firstname, :lastname, :age),Tuple{Array{String,1},Array{String,1},Array{Int64,1}}}},Dict{String,Array{Int64,1}}} with 4 entries:\n  \nKing\n     =\n Table with 3 columns and 1 row:\u2026\n  \nWilliams\n =\n Table with 3 columns and 2 rows:\u2026\n  \nBrown\n    =\n Table with 3 columns and 1 row:\u2026\n  \nSmith\n    =\n Table with 3 columns and 3 rows:\u2026\n\n\n\n\nThe results are only summarized (for compactness), but can be easily accessed.\n\n\njulia\n groups[\nSmith\n]\nTable with 3 columns and 3 rows:\n     firstname  lastname  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice      Smith     25\n 2 \u2502 Bob        Smith     42\n 3 \u2502 Charlie    Smith     37\n\n\n\n\n\n\nLazy grouping\n\n\nThere are additional functions provided to do grouping while copying less data.\n\n\nA \ngroupinds\n function let's you identify the indices of the rows belonging to certain groups.\n\n\njulia\n lastname_inds = groupinds(t.lastname)\nDict{String,Array{Int64,1}} with 4 entries:\n  \nKing\n     =\n [7]\n  \nWilliams\n =\n [4, 5]\n  \nBrown\n    =\n [6]\n  \nSmith\n    =\n [1, 2, 3]\n\n\n\n\nWe can then use these indices to perform calculations on each group of data, for example the mean age per lastname grouping.\n\n\njulia\n using Statistics\n\njulia\n Dict(lastname =\n mean(t.age[inds]) for (lastname, inds) in lastname_inds)\nDict{String,Float64} with 4 entries:\n  \nKing\n     =\n 54.0\n  \nWilliams\n =\n 41.5\n  \nBrown\n    =\n 33.0\n  \nSmith\n    =\n 34.6667\n\n\n\n\nThere is additionally a \ngroupview\n function, which calculates the \ngroupinds\n and constructs each subset as a \nview\n.\n\n\n\n\nSummarizing groups with \ngroupreduce\n\n\nSometimes we can perform a split-apply-combine strategy by streaming just once over the data, and reducing over the groups. The \ngroupreduce\n function lets us do this, and can be more performant than alternative approaches.\n\n\nFor example, we can sum up the ages corresponding to each family name.\n\n\njulia\n groupreduce(getproperty(:lastname), +, getproperty(:age), t)\nDict{String,Int64} with 4 entries:\n  \nKing\n     =\n 54\n  \nWilliams\n =\n 83\n  \nBrown\n    =\n 33\n  \nSmith\n    =\n 104\n\n\n\n\nSplitApplyCombine\n provides related functions \ngroupsum\n, \ngroupprod\n, and so-on. One particularly handy function for summarizing data by giving counts of unique values is \ngroupcount\n.\n\n\njulia\n groupcount(t.lastname)\nDict{String,Int64} with 4 entries:\n  \nKing\n     =\n 1\n  \nWilliams\n =\n 2\n  \nBrown\n    =\n 1\n  \nSmith\n    =\n 3", 
            "title": "Grouping data"
        }, 
        {
            "location": "/man/group/#grouping-data", 
            "text": "It is frequently useful to break data appart into different  groups  for processing - a paradigm frequently referred to a the split-apply-combine methodology.  In a powerful environment such as Julia, that fully supports nested containers, it makes sense to represent each group as distinct containers, with an outer container acting as a \"dictionary\" of the groups. This is in contrast to environments with a less rich system of containers, such as SQL, which has popularized a slightly different notion of grouping data into a single flat tabular structure, where one (or more) columns act as the grouping key. Here we focus on the former approach.", 
            "title": "Grouping data"
        }, 
        {
            "location": "/man/group/#using-the-group-function", 
            "text": "SplitApplyCombine  provides a  group  function, which can operate on arbitary Julia objects. The function has the signature  group(by, f, iter)  where  iter  is a container that can be iterated,  by  is a function from the elements of  iter  to the grouping  key , and the optional argument  f  is a mapping applied to the grouped elements (by default,  f = identity , the identity function).  To demonstrate the power of grouping, this time we'll add some more rows and columns to our example data.  julia  t = Table(firstname = [ Alice ,  Bob ,  Charlie ,  Adam ,  Eve ,  Cindy ,  Arthur ], lastname = [ Smith ,  Smith ,  Smith ,  Williams ,  Williams ,  Brown ,  King ], age = [25, 42, 37, 65, 18, 33, 54])\nTable with 3 columns and 7 rows:\n     firstname  lastname  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice      Smith     25\n 2 \u2502 Bob        Smith     42\n 3 \u2502 Charlie    Smith     37\n 4 \u2502 Adam       Williams  65\n 5 \u2502 Eve        Williams  18\n 6 \u2502 Cindy      Brown     33\n 7 \u2502 Arthur     King      54  Let's get familiar with the  basic  usage of  group  on standard (non-tabular) arrays. For example, let's group people's first name by their first letter.  julia  group(first, t.firstname)\nDict{Char,Array{String,1}} with 4 entries:\n  'C' =  [ Charlie ,  Cindy ]\n  'A' =  [ Alice ,  Adam ,  Arthur ]\n  'E' =  [ Eve ]\n  'B' =  [ Bob ]  The groups are returned as a  Dict  where they indices (or keys) of the dictionary are the first character of people's firstname string. The values of the  Dict  are arrays listing the matching firstnames.  Next, we may want to group up data coming from a table (not just a single column). For example, we may want to group firstnames by lastname.  julia  group(getproperty(:lastname), getproperty(:firstname), t)\nDict{String,Array{String,1}} with 4 entries:\n   King      =  [ Arthur ]\n   Williams  =  [ Adam ,  Eve ]\n   Brown     =  [ Cindy ]\n   Smith     =  [ Alice ,  Bob ,  Charlie ]  Note that the returned structure is still not a  Table  at all - it is a dictionary ( Dict ) with the unique  lastname  values as keys, returing (non-tabular) arrays of  firstname .  If instead, our grouping elements are  rows , the group will be a table. For example, we can just drop the  getproperty(:firstname)  projection to get:  julia  groups = group(getproperty(:lastname), t)\nGroups{String,Any,Table{NamedTuple{(:firstname, :lastname, :age),Tuple{String,String,Int64}},1,NamedTuple{(:firstname, :lastname, :age),Tuple{Array{String,1},Array{String,1},Array{Int64,1}}}},Dict{String,Array{Int64,1}}} with 4 entries:\n   King      =  Table with 3 columns and 1 row:\u2026\n   Williams  =  Table with 3 columns and 2 rows:\u2026\n   Brown     =  Table with 3 columns and 1 row:\u2026\n   Smith     =  Table with 3 columns and 3 rows:\u2026  The results are only summarized (for compactness), but can be easily accessed.  julia  groups[ Smith ]\nTable with 3 columns and 3 rows:\n     firstname  lastname  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice      Smith     25\n 2 \u2502 Bob        Smith     42\n 3 \u2502 Charlie    Smith     37", 
            "title": "Using the group function"
        }, 
        {
            "location": "/man/group/#lazy-grouping", 
            "text": "There are additional functions provided to do grouping while copying less data.  A  groupinds  function let's you identify the indices of the rows belonging to certain groups.  julia  lastname_inds = groupinds(t.lastname)\nDict{String,Array{Int64,1}} with 4 entries:\n   King      =  [7]\n   Williams  =  [4, 5]\n   Brown     =  [6]\n   Smith     =  [1, 2, 3]  We can then use these indices to perform calculations on each group of data, for example the mean age per lastname grouping.  julia  using Statistics\n\njulia  Dict(lastname =  mean(t.age[inds]) for (lastname, inds) in lastname_inds)\nDict{String,Float64} with 4 entries:\n   King      =  54.0\n   Williams  =  41.5\n   Brown     =  33.0\n   Smith     =  34.6667  There is additionally a  groupview  function, which calculates the  groupinds  and constructs each subset as a  view .", 
            "title": "Lazy grouping"
        }, 
        {
            "location": "/man/group/#summarizing-groups-with-groupreduce", 
            "text": "Sometimes we can perform a split-apply-combine strategy by streaming just once over the data, and reducing over the groups. The  groupreduce  function lets us do this, and can be more performant than alternative approaches.  For example, we can sum up the ages corresponding to each family name.  julia  groupreduce(getproperty(:lastname), +, getproperty(:age), t)\nDict{String,Int64} with 4 entries:\n   King      =  54\n   Williams  =  83\n   Brown     =  33\n   Smith     =  104  SplitApplyCombine  provides related functions  groupsum ,  groupprod , and so-on. One particularly handy function for summarizing data by giving counts of unique values is  groupcount .  julia  groupcount(t.lastname)\nDict{String,Int64} with 4 entries:\n   King      =  1\n   Williams  =  2\n   Brown     =  1\n   Smith     =  3", 
            "title": "Summarizing groups with groupreduce"
        }, 
        {
            "location": "/man/join/", 
            "text": "Joining data\n\n\nThe methods defined so far work on single data sources (tables) at-a-time. Sometimes, we need to \njoin\n information together from multiple tables.\n\n\n\n\nCartesian product/join of tables\n\n\nBefore progressing to the typical \"join\" operations on tables, we'll discuss the Cartesian product (or Cartesian \"join\") between two tables. In SQL, this is called the \nCROSS JOIN\n.\n\n\nSuppose \ntable1\n has \nn\n rows, and \ntable2\n has \nm\n rows. We can create a new table that contains \nn \u00d7 m\n rows with the data from \ntable1\n and \ntable2\n. In fact, if the output \ntable3\n were an \nn \u00d7 m\n \nmatrix\n of rows, we could say that the row \ntable3[i, j]\n contains the combination of \ntable1[i]\n and \ntable2[j]\n.\n\n\nThe easiest way to do this is with the \nSplitApplyCombine.product\n. For a quick primer, \nout = product(f, a, b)\n returns an array \nout\n such that \nout[i, j] = f(a, b)\n. For example, let's take all combinations of the sums of \n[1, 2, 3]\n and \n[10, 20, 30, 40]\n.\n\n\njulia\n product(+, [1, 2, 3], [10, 20, 30, 40])\n3\u00d74 Array{Int64,2}:\n 11  21  31  41\n 12  22  32  42\n 13  23  33  43\n\n\n\n\nOne can also use \ntuple\n to simply collect both sets of data.\n\n\njulia\n product(tuple, [1, 2, 3], [10, 20, 30, 40])\n3\u00d74 Array{Tuple{Int64,Int64},2}:\n (1, 10)  (1, 20)  (1, 30)  (1, 40)\n (2, 10)  (2, 20)  (2, 30)  (2, 40)\n (3, 10)  (3, 20)  (3, 30)  (3, 40)\n\n\n\n\n(Note that \ntuple\n is the \nonly\n option for the similar function \nIterators.product\n). Let's try this with a table. This time, for two tables with \ndistinct\n column names, we can use the \nmerge\n function to merge the rows into single \nNamedTuple\ns - for example, take this list of all pairings of firstnames and lastnames.\n\n\njulia\n t1 = Table(firstname = [\nAlice\n, \nBob\n, \nCharlie\n])\nTable with 1 column and 3 rows:\n     firstname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Bob\n 3 \u2502 Charlie\n\njulia\n t2 = Table(lastname = [\nSmith\n, \nWilliams\n, \nBrown\n, \nKing\n])\nTable with 1 column and 4 rows:\n     lastname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Smith\n 2 \u2502 Williams\n 3 \u2502 Brown\n 4 \u2502 King\n\njulia\n t3 = product(merge, t1, t2)\nTable with 2 columns and 3\u00d74 rows:\n       firstname  lastname\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1,1 \u2502 Alice      Smith\n 2,1 \u2502 Bob        Smith\n 3,1 \u2502 Charlie    Smith\n 1,2 \u2502 Alice      Williams\n 2,2 \u2502 Bob        Williams\n 3,2 \u2502 Charlie    Williams\n 1,3 \u2502 Alice      Brown\n 2,3 \u2502 Bob        Brown\n 3,3 \u2502 Charlie    Brown\n 1,4 \u2502 Alice      King\n 2,4 \u2502 Bob        King\n 3,4 \u2502 Charlie    King\n\njulia\n size(t3)\n(3, 4)\n\n\n\n\nRemember that one must be careful that the column names are indeed distinct when using \nproduct(merge, ...)\n this way.\n\n\nThis is our first example of a \nTable\n which an array of higher than one-dimension - it is an \nAbstractMatrix\n. The \nproduct\n of many tables may be a \n3\n- or higher-dimensional array. Note that higher-dimensional tables do not print as a matrix like other higher-dimensional arrays at the REPL, as this would quickly obscure the columns. Instead, the indices are displayed to the left of each row.\n\n\nFinally, also note that there is a \nproductview\n function for performing this operation lazily. This may be crucial to remember - the size of the output is the \nproduct\n of the size of the inputs, which grows very quickly even for very reasonably sized input tables. This operation can be very expensive in both time and memory if appropriate care isn't taken.\n\n\n\n\nCartesian product with generators\n\n\nOne can feed in multiple inputs into a generator, and Julia will automatically take the Cartesian product of all inputs. For example:\n\n\njulia\n t3 = Table(merge(row1, row2) for row1 in t1, row2 in t2)\nTable with 2 columns and 12 rows:\n      firstname  lastname\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1  \u2502 Alice      Smith\n 2  \u2502 Bob        Smith\n 3  \u2502 Charlie    Smith\n 4  \u2502 Alice      Williams\n 5  \u2502 Bob        Williams\n 6  \u2502 Charlie    Williams\n 7  \u2502 Alice      Brown\n 8  \u2502 Bob        Brown\n 9  \u2502 Charlie    Brown\n 10 \u2502 Alice      King\n 11 \u2502 Bob        King\n 12 \u2502 Charlie    King\n\n\n\n\n\n\nRelational \"join\"\n\n\nIn a nutshell: the relational \"join\" operation is simply the above Cartesian product followed by a filtering operation. Generally, the filtering operation will depend on information coming from \nboth\n input data sets - for example, that the values in a particular column must match exactly. (Any filtering that depends only on information from one input table can be done more efficiently \nbefore\n the join operation).\n\n\nFor a simple example, let's look for all pairings of firstnames and lastnames that have an equal number of characters. For efficiency, we combine this with \nproductview\n.\n\n\njulia\n filter(row -\n length(row.firstname) == length(row.lastname), t3)\nTable with 2 columns and 2 rows:\n     firstname  lastname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice      Smith\n 2 \u2502 Alice      Brown\n\n\n\n\nMany might find that this two-step process a rather indirect way of performing a join operation. Below we cover two more standard techniques.\n\n\n\n\nUsing primary and foreign keys\n\n\nBefore launching into \ninnerjoin\n, it is worth taking a detour to expore a common case where a far simpler operation can perform the requisite join - indexing!\n\n\nIn a relation, a \"primary\" key is a column (or multiple columns) with values that uniquely identify the row - no two rows may have the same primary key. \nTable\n and \nFlexTable\n do not \ndirectly\n support uniqueness in the columns (though the \narray\n corresponding to a column could surely enforce uniqueness). However, each row \nis\n uniquely identified by it's index, for example \nt1[1]\n corresponds to the row \n(firstname = \"Alice\",)\n.\n\n\nIn fact, using the array index as the primary key can be the most efficient way of uniquely identifying your data. A second table with related data may indeed have a column containing the indices of relevant rows in the first table. Such columns are generally referred to as being a \"foreign key\" (they uniquely identify data in a \"foreign\" table).\n\n\nAs an example, let's take a simplistic \ncustomers\n and \norders\n database.\n\n\njulia\n customers = Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], address = [\n12 Beach Street\n, \n163 Moon Road\n, \n6 George Street\n])\nTable with 2 columns and 3 rows:\n     name     address\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    12 Beach Street\n 2 \u2502 Bob      163 Moon Road\n 3 \u2502 Charlie  6 George Street\n\njulia\n orders = Table(customer_id = [2, 2, 3, 3], items = [\nSocks\n, \nTie\n, \nShirt\n, \nUnderwear\n])\nTable with 2 columns and 4 rows:\n     customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2            Socks\n 2 \u2502 2            Tie\n 3 \u2502 3            Shirt\n 4 \u2502 3            Underwear\n\n\n\n\nTo get the customer for each order is just a simple indexing operation.\n\n\njulia\n customers[orders.customer_id]\nTable with 2 columns and 4 rows:\n     name     address\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob      163 Moon Road\n 2 \u2502 Bob      163 Moon Road\n 3 \u2502 Charlie  6 George Street\n 4 \u2502 Charlie  6 George Street\n\n\n\n\n\nWe can denormalize the orders and their customers to a single table by performing a \nmerge\n on each row (in this case using broadcasting dot-syntax for brevity).\n\n\njulia\n merge.(customers[orders.customer_id], orders)\nTable with 4 columns and 4 rows:\n     name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob      163 Moon Road    2            Socks\n 2 \u2502 Bob      163 Moon Road    2            Tie\n 3 \u2502 Charlie  6 George Street  3            Shirt\n 4 \u2502 Charlie  6 George Street  3            Underwear\n\n\n\n\n\nWe can perform these operation lazily for cost \nO\n(1) using \nview\n and \nmapview\n - after which the data can be processed further.\n\n\njulia\n mapview(merge, view(customers, orders.customer_id), orders)\nTable with 4 columns and 4 rows:\n     name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob      163 Moon Road    2            Socks\n 2 \u2502 Bob      163 Moon Road    2            Tie\n 3 \u2502 Charlie  6 George Street  3            Shirt\n 4 \u2502 Charlie  6 George Street  3            Underwear\n\n\n\n\nThis is a simple and powerful technique. By \nnormalizing\n your one-to-many relationships into multiple tables using the array index as primary and foreign keys, you can join your data together quickly and efficiently with (possibly lazy) indexing.\n\n\n\n\nInner join\n\n\nWe now turn out attention to the relational join, implemented via \nSplitApplyCombine\n's \ninnerjoin\n function (note that the \njoin\n function in \nBase\n is a concatenation operation on strings, not a relational operation on tables).\n\n\nThe \ninnerjoin\n function is flexible, able to join any iterable data source via any comparing predicate, and perform an arbitrary mapping of the matching results. Using \n?\n, we can view its documentation at the REPL:\n\n\nhelp?\n innerjoin\nsearch: innerjoin\n\n  innerjoin(lkey, rkey, f, comparison, left, right)\n\n  Performs a relational-style join operation between iterables left and right,\n  returning a collection of elements f(l, r) for which comparison(lkey(l), rkey(r))\n  is true where l \u2208 left, r \u2208 right.\n\n  Example\n  \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\n\n  julia\n innerjoin(iseven, iseven, tuple, ==, [1,2,3,4], [0,1,2])\n  6-element Array{Tuple{Int64,Int64},1}:\n   (1, 1)\n   (2, 0)\n   (2, 2)\n   (3, 1)\n   (4, 0)\n   (4, 2)\n\n\n\n\nLet's examine this. Assume the inputs \nleft\n and \nright\n are \nTable\ns. We may want to join the tables via a single column each, in which case \ngetproperty(:name)\n would be suitable for \nlkey\n and \nrkey\n. In the simplest case, such as a natural join, for \nf\n we may want to \nmerge\n all the columns from both input tables (which is the default for \nf\n), and the \ncomparison\n operator may be equality (it defaults to \nisequal\n).\n\n\nAs an example, we modify our \ncustomers\n table to explicitly include the customer's \nid\n, similarly to above.\n\n\njulia\n customers = Table(id = 1:3, name = [\nAlice\n, \nBob\n, \nCharlie\n], address = [\n12 Beach Street\n, \n163 Moon Road\n, \n6 George Street\n])\nTable with 3 columns and 3 rows:\n     id  name     address\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 1   Alice    12 Beach Street\n 2 \u2502 2   Bob      163 Moon Road\n 3 \u2502 3   Charlie  6 George Street\n\njulia\n innerjoin(getproperty(:id), getproperty(:customer_id), customers, orders)\nTable with 5 columns and 4 rows:\n     id  name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2   Bob      163 Moon Road    2            Socks\n 2 \u2502 2   Bob      163 Moon Road    2            Tie\n 3 \u2502 3   Charlie  6 George Street  3            Shirt\n 4 \u2502 3   Charlie  6 George Street  3            Underwear\n\n\n\n\nThe \ninnerjoin\n function can be used to join any tables based on any conditions. However, by default only the \nisequal\n comparison is accelerated via a temporary hash index - all other comparisons will invoke an exhaustive \nO\n(\nn^2\n) algorithm.\n\n\nSee the section on Acceleration Indices for methods of (a) attaching secondary acceleration indices to your columns, and (b) using these to accelerate operations using comparisons other than \nisequal\n. For example, a \nSortIndex\n can be used to accelerate joins on order-related predicates, such as the value in one column being smaller than another column.\n\n\n\n\nInner joins with generators\n\n\nAs a final example, generators provide a convenient syntax for filtering Cartesian products of collections - that is, to perform an inner join!\n\n\njulia\n Table(merge(customer, order) for customer in customers, order in orders if customer.id == order.customer_id)\nTable with 5 columns and 4 rows:\n     id  name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2   Bob      163 Moon Road    2            Socks\n 2 \u2502 2   Bob      163 Moon Road    2            Tie\n 3 \u2502 3   Charlie  6 George Street  3            Shirt\n 4 \u2502 3   Charlie  6 George Street  3            Underwear\n\n\n\n\nThe disadvantage of this technique is that it will perform an exhaustive search by default, costing \nO\n(\nn^2\n).\n\n\n\n\nLeft-group-join\n\n\nCurrently \nSplitApplyCombine\n and \nTypedTables\n do not provide what in SQL is called an \nLEFT OUTER JOIN\n (or any of the other \nOUTER JOIN\n operations).\n\n\nSuch a query can be alternatively modeled as a hybrid group/join operation. \nSplitApplyCombine\n provides \nleftgroupjoin\n to perform precisely this. This is similar to LINQ's \nGroupJoin\n method. Let us investigate this query with the same data as for \ninnerjoin\n, above.\n\n\njulia\n groups = leftgroupjoin(getproperty(:id), getproperty(:customer_id), customers, orders)\nDict{Int64,Table{NamedTuple{(:id, :name, :address, :customer_id, :items),Tuple{Int64,String,String,Int64,String}},1,NamedTuple{(:id, :name, :address, :customer_id, :items),Tuple{Array{Int64,1},Array{String,1},Array{String,1},Array{Int64,1},Array{String,1}}}}} with 3 entries:\n  2 =\n Table with 5 columns and 2 rows:\u2026\n  3 =\n Table with 5 columns and 2 rows:\u2026\n  1 =\n Table with 5 columns and 0 rows:\u2026\n\njulia\n groups[1]\nTable with 5 columns and 0 rows:\n     id  name  address  customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\njulia\n groups[2]\nTable with 5 columns and 2 rows:\n     id  name  address        customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2   Bob   163 Moon Road  2            Socks\n 2 \u2502 2   Bob   163 Moon Road  2            Tie\n\njulia\n groups[3]\nTable with 5 columns and 2 rows:\n     id  name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 3   Charlie  6 George Street  3            Shirt\n 2 \u2502 3   Charlie  6 George Street  3            Underwear\n\n\n\n\nAs you can see - 3 groups were identified, according to the distinct keys in the \nid\n column of \ncustomers\n. While the first customer had no associated orders, note that an empty group has nonetheless been created. Much like SQL's \nLEFT OUTER JOIN\n command, \nleftgroupjoin\n lets us handle the case that no matching data is found. While SQL achieves this by noting there is \nmissing\n data in the columns associated with the right table, here we use a set of nested containers (dictionaries of tables of rows) to denote the relationship.", 
            "title": "Joining data"
        }, 
        {
            "location": "/man/join/#joining-data", 
            "text": "The methods defined so far work on single data sources (tables) at-a-time. Sometimes, we need to  join  information together from multiple tables.", 
            "title": "Joining data"
        }, 
        {
            "location": "/man/join/#cartesian-productjoin-of-tables", 
            "text": "Before progressing to the typical \"join\" operations on tables, we'll discuss the Cartesian product (or Cartesian \"join\") between two tables. In SQL, this is called the  CROSS JOIN .  Suppose  table1  has  n  rows, and  table2  has  m  rows. We can create a new table that contains  n \u00d7 m  rows with the data from  table1  and  table2 . In fact, if the output  table3  were an  n \u00d7 m   matrix  of rows, we could say that the row  table3[i, j]  contains the combination of  table1[i]  and  table2[j] .  The easiest way to do this is with the  SplitApplyCombine.product . For a quick primer,  out = product(f, a, b)  returns an array  out  such that  out[i, j] = f(a, b) . For example, let's take all combinations of the sums of  [1, 2, 3]  and  [10, 20, 30, 40] .  julia  product(+, [1, 2, 3], [10, 20, 30, 40])\n3\u00d74 Array{Int64,2}:\n 11  21  31  41\n 12  22  32  42\n 13  23  33  43  One can also use  tuple  to simply collect both sets of data.  julia  product(tuple, [1, 2, 3], [10, 20, 30, 40])\n3\u00d74 Array{Tuple{Int64,Int64},2}:\n (1, 10)  (1, 20)  (1, 30)  (1, 40)\n (2, 10)  (2, 20)  (2, 30)  (2, 40)\n (3, 10)  (3, 20)  (3, 30)  (3, 40)  (Note that  tuple  is the  only  option for the similar function  Iterators.product ). Let's try this with a table. This time, for two tables with  distinct  column names, we can use the  merge  function to merge the rows into single  NamedTuple s - for example, take this list of all pairings of firstnames and lastnames.  julia  t1 = Table(firstname = [ Alice ,  Bob ,  Charlie ])\nTable with 1 column and 3 rows:\n     firstname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Bob\n 3 \u2502 Charlie\n\njulia  t2 = Table(lastname = [ Smith ,  Williams ,  Brown ,  King ])\nTable with 1 column and 4 rows:\n     lastname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Smith\n 2 \u2502 Williams\n 3 \u2502 Brown\n 4 \u2502 King\n\njulia  t3 = product(merge, t1, t2)\nTable with 2 columns and 3\u00d74 rows:\n       firstname  lastname\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1,1 \u2502 Alice      Smith\n 2,1 \u2502 Bob        Smith\n 3,1 \u2502 Charlie    Smith\n 1,2 \u2502 Alice      Williams\n 2,2 \u2502 Bob        Williams\n 3,2 \u2502 Charlie    Williams\n 1,3 \u2502 Alice      Brown\n 2,3 \u2502 Bob        Brown\n 3,3 \u2502 Charlie    Brown\n 1,4 \u2502 Alice      King\n 2,4 \u2502 Bob        King\n 3,4 \u2502 Charlie    King\n\njulia  size(t3)\n(3, 4)  Remember that one must be careful that the column names are indeed distinct when using  product(merge, ...)  this way.  This is our first example of a  Table  which an array of higher than one-dimension - it is an  AbstractMatrix . The  product  of many tables may be a  3 - or higher-dimensional array. Note that higher-dimensional tables do not print as a matrix like other higher-dimensional arrays at the REPL, as this would quickly obscure the columns. Instead, the indices are displayed to the left of each row.  Finally, also note that there is a  productview  function for performing this operation lazily. This may be crucial to remember - the size of the output is the  product  of the size of the inputs, which grows very quickly even for very reasonably sized input tables. This operation can be very expensive in both time and memory if appropriate care isn't taken.", 
            "title": "Cartesian product/join of tables"
        }, 
        {
            "location": "/man/join/#cartesian-product-with-generators", 
            "text": "One can feed in multiple inputs into a generator, and Julia will automatically take the Cartesian product of all inputs. For example:  julia  t3 = Table(merge(row1, row2) for row1 in t1, row2 in t2)\nTable with 2 columns and 12 rows:\n      firstname  lastname\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1  \u2502 Alice      Smith\n 2  \u2502 Bob        Smith\n 3  \u2502 Charlie    Smith\n 4  \u2502 Alice      Williams\n 5  \u2502 Bob        Williams\n 6  \u2502 Charlie    Williams\n 7  \u2502 Alice      Brown\n 8  \u2502 Bob        Brown\n 9  \u2502 Charlie    Brown\n 10 \u2502 Alice      King\n 11 \u2502 Bob        King\n 12 \u2502 Charlie    King", 
            "title": "Cartesian product with generators"
        }, 
        {
            "location": "/man/join/#relational-join", 
            "text": "In a nutshell: the relational \"join\" operation is simply the above Cartesian product followed by a filtering operation. Generally, the filtering operation will depend on information coming from  both  input data sets - for example, that the values in a particular column must match exactly. (Any filtering that depends only on information from one input table can be done more efficiently  before  the join operation).  For a simple example, let's look for all pairings of firstnames and lastnames that have an equal number of characters. For efficiency, we combine this with  productview .  julia  filter(row -  length(row.firstname) == length(row.lastname), t3)\nTable with 2 columns and 2 rows:\n     firstname  lastname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice      Smith\n 2 \u2502 Alice      Brown  Many might find that this two-step process a rather indirect way of performing a join operation. Below we cover two more standard techniques.", 
            "title": "Relational \"join\""
        }, 
        {
            "location": "/man/join/#using-primary-and-foreign-keys", 
            "text": "Before launching into  innerjoin , it is worth taking a detour to expore a common case where a far simpler operation can perform the requisite join - indexing!  In a relation, a \"primary\" key is a column (or multiple columns) with values that uniquely identify the row - no two rows may have the same primary key.  Table  and  FlexTable  do not  directly  support uniqueness in the columns (though the  array  corresponding to a column could surely enforce uniqueness). However, each row  is  uniquely identified by it's index, for example  t1[1]  corresponds to the row  (firstname = \"Alice\",) .  In fact, using the array index as the primary key can be the most efficient way of uniquely identifying your data. A second table with related data may indeed have a column containing the indices of relevant rows in the first table. Such columns are generally referred to as being a \"foreign key\" (they uniquely identify data in a \"foreign\" table).  As an example, let's take a simplistic  customers  and  orders  database.  julia  customers = Table(name = [ Alice ,  Bob ,  Charlie ], address = [ 12 Beach Street ,  163 Moon Road ,  6 George Street ])\nTable with 2 columns and 3 rows:\n     name     address\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    12 Beach Street\n 2 \u2502 Bob      163 Moon Road\n 3 \u2502 Charlie  6 George Street\n\njulia  orders = Table(customer_id = [2, 2, 3, 3], items = [ Socks ,  Tie ,  Shirt ,  Underwear ])\nTable with 2 columns and 4 rows:\n     customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2            Socks\n 2 \u2502 2            Tie\n 3 \u2502 3            Shirt\n 4 \u2502 3            Underwear  To get the customer for each order is just a simple indexing operation.  julia  customers[orders.customer_id]\nTable with 2 columns and 4 rows:\n     name     address\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob      163 Moon Road\n 2 \u2502 Bob      163 Moon Road\n 3 \u2502 Charlie  6 George Street\n 4 \u2502 Charlie  6 George Street  We can denormalize the orders and their customers to a single table by performing a  merge  on each row (in this case using broadcasting dot-syntax for brevity).  julia  merge.(customers[orders.customer_id], orders)\nTable with 4 columns and 4 rows:\n     name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob      163 Moon Road    2            Socks\n 2 \u2502 Bob      163 Moon Road    2            Tie\n 3 \u2502 Charlie  6 George Street  3            Shirt\n 4 \u2502 Charlie  6 George Street  3            Underwear  We can perform these operation lazily for cost  O (1) using  view  and  mapview  - after which the data can be processed further.  julia  mapview(merge, view(customers, orders.customer_id), orders)\nTable with 4 columns and 4 rows:\n     name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob      163 Moon Road    2            Socks\n 2 \u2502 Bob      163 Moon Road    2            Tie\n 3 \u2502 Charlie  6 George Street  3            Shirt\n 4 \u2502 Charlie  6 George Street  3            Underwear  This is a simple and powerful technique. By  normalizing  your one-to-many relationships into multiple tables using the array index as primary and foreign keys, you can join your data together quickly and efficiently with (possibly lazy) indexing.", 
            "title": "Using primary and foreign keys"
        }, 
        {
            "location": "/man/join/#inner-join", 
            "text": "We now turn out attention to the relational join, implemented via  SplitApplyCombine 's  innerjoin  function (note that the  join  function in  Base  is a concatenation operation on strings, not a relational operation on tables).  The  innerjoin  function is flexible, able to join any iterable data source via any comparing predicate, and perform an arbitrary mapping of the matching results. Using  ? , we can view its documentation at the REPL:  help?  innerjoin\nsearch: innerjoin\n\n  innerjoin(lkey, rkey, f, comparison, left, right)\n\n  Performs a relational-style join operation between iterables left and right,\n  returning a collection of elements f(l, r) for which comparison(lkey(l), rkey(r))\n  is true where l \u2208 left, r \u2208 right.\n\n  Example\n  \u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\u2261\n\n  julia  innerjoin(iseven, iseven, tuple, ==, [1,2,3,4], [0,1,2])\n  6-element Array{Tuple{Int64,Int64},1}:\n   (1, 1)\n   (2, 0)\n   (2, 2)\n   (3, 1)\n   (4, 0)\n   (4, 2)  Let's examine this. Assume the inputs  left  and  right  are  Table s. We may want to join the tables via a single column each, in which case  getproperty(:name)  would be suitable for  lkey  and  rkey . In the simplest case, such as a natural join, for  f  we may want to  merge  all the columns from both input tables (which is the default for  f ), and the  comparison  operator may be equality (it defaults to  isequal ).  As an example, we modify our  customers  table to explicitly include the customer's  id , similarly to above.  julia  customers = Table(id = 1:3, name = [ Alice ,  Bob ,  Charlie ], address = [ 12 Beach Street ,  163 Moon Road ,  6 George Street ])\nTable with 3 columns and 3 rows:\n     id  name     address\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 1   Alice    12 Beach Street\n 2 \u2502 2   Bob      163 Moon Road\n 3 \u2502 3   Charlie  6 George Street\n\njulia  innerjoin(getproperty(:id), getproperty(:customer_id), customers, orders)\nTable with 5 columns and 4 rows:\n     id  name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2   Bob      163 Moon Road    2            Socks\n 2 \u2502 2   Bob      163 Moon Road    2            Tie\n 3 \u2502 3   Charlie  6 George Street  3            Shirt\n 4 \u2502 3   Charlie  6 George Street  3            Underwear  The  innerjoin  function can be used to join any tables based on any conditions. However, by default only the  isequal  comparison is accelerated via a temporary hash index - all other comparisons will invoke an exhaustive  O ( n^2 ) algorithm.  See the section on Acceleration Indices for methods of (a) attaching secondary acceleration indices to your columns, and (b) using these to accelerate operations using comparisons other than  isequal . For example, a  SortIndex  can be used to accelerate joins on order-related predicates, such as the value in one column being smaller than another column.", 
            "title": "Inner join"
        }, 
        {
            "location": "/man/join/#inner-joins-with-generators", 
            "text": "As a final example, generators provide a convenient syntax for filtering Cartesian products of collections - that is, to perform an inner join!  julia  Table(merge(customer, order) for customer in customers, order in orders if customer.id == order.customer_id)\nTable with 5 columns and 4 rows:\n     id  name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2   Bob      163 Moon Road    2            Socks\n 2 \u2502 2   Bob      163 Moon Road    2            Tie\n 3 \u2502 3   Charlie  6 George Street  3            Shirt\n 4 \u2502 3   Charlie  6 George Street  3            Underwear  The disadvantage of this technique is that it will perform an exhaustive search by default, costing  O ( n^2 ).", 
            "title": "Inner joins with generators"
        }, 
        {
            "location": "/man/join/#left-group-join", 
            "text": "Currently  SplitApplyCombine  and  TypedTables  do not provide what in SQL is called an  LEFT OUTER JOIN  (or any of the other  OUTER JOIN  operations).  Such a query can be alternatively modeled as a hybrid group/join operation.  SplitApplyCombine  provides  leftgroupjoin  to perform precisely this. This is similar to LINQ's  GroupJoin  method. Let us investigate this query with the same data as for  innerjoin , above.  julia  groups = leftgroupjoin(getproperty(:id), getproperty(:customer_id), customers, orders)\nDict{Int64,Table{NamedTuple{(:id, :name, :address, :customer_id, :items),Tuple{Int64,String,String,Int64,String}},1,NamedTuple{(:id, :name, :address, :customer_id, :items),Tuple{Array{Int64,1},Array{String,1},Array{String,1},Array{Int64,1},Array{String,1}}}}} with 3 entries:\n  2 =  Table with 5 columns and 2 rows:\u2026\n  3 =  Table with 5 columns and 2 rows:\u2026\n  1 =  Table with 5 columns and 0 rows:\u2026\n\njulia  groups[1]\nTable with 5 columns and 0 rows:\n     id  name  address  customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\njulia  groups[2]\nTable with 5 columns and 2 rows:\n     id  name  address        customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 2   Bob   163 Moon Road  2            Socks\n 2 \u2502 2   Bob   163 Moon Road  2            Tie\n\njulia  groups[3]\nTable with 5 columns and 2 rows:\n     id  name     address          customer_id  items\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 3   Charlie  6 George Street  3            Shirt\n 2 \u2502 3   Charlie  6 George Street  3            Underwear  As you can see - 3 groups were identified, according to the distinct keys in the  id  column of  customers . While the first customer had no associated orders, note that an empty group has nonetheless been created. Much like SQL's  LEFT OUTER JOIN  command,  leftgroupjoin  lets us handle the case that no matching data is found. While SQL achieves this by noting there is  missing  data in the columns associated with the right table, here we use a set of nested containers (dictionaries of tables of rows) to denote the relationship.", 
            "title": "Left-group-join"
        }, 
        {
            "location": "/man/acceleratedarrays/", 
            "text": "Acceleration Indices with \nAcceleratedArrays\n\n\nDatabase systems have evolved many performance tricks over the years to achieve efficiency and scalability. In an environment such as a SQL RDBMS, much effort is put into the creation of an efficient \"query planner\" that will essentially construct a small computer program, ultimately made up of nested loops, searching, mapping and filtering operations, to perform a query. However, the second \"magic\" ingredient used by an RDBMS for performance are secondary \"acceleration indices\", which are pre-calculated views of the data. These views help queries find data that match certain conditions - a hash-map index well let us locate a matching entry in \nO\n(1), or a sort-based index will let us quickly locate \nall\n the cells less than (or more than) a certain value.\n\n\nFor at least some of the kinds of data analytics performed in Julia, it may be possible to expect the programmer to write and execute their own query plan - that is, to understand their data model, to predict the \"statistics\" regarding the size of and other properties of the data, and to come up with their own rough order of operations that may be efficient. Thus, we may not need to implement a complete query planner to make a viable platform for data analytics in Julia - however, we will absolutely need acceleration indices to perform each elementary operation fast. In the worst case, the programmer would have to construct their own hash-maps and sort-indices (and use them in their own hand-written loops) to obtain peak performance.\n\n\nThe \nAcceleratedArrays\n package exists to provide a way of attaching secondary acceleration indices to any array in Julia, to speed up operations such as \nfilter\n, \nfindall\n, \ngroup\n and \ninnerjoin\n in a transparent and generic way. These acceleration indices can be attached to arbitrary columns (or indeed, entire \nTable\ns). These indices remain silently attached to their parent array until they encounter an operation they can accelerate. The user is free to write \ngeneric\n code to execute their query, and the presence of the acceleration index will only act to speed up the resulting specialized algorithm constructed by Julia's compiler.\n\n\nThis system allows for an extensible set of acceleration indices - such as accelerated spatial lookup using a spatial search tree, or an inverted index for searching for words in text fields. \n\n\nNote: by default, the \ninnerjoin\n operation will construct a hash-based index to perform a join on two unindexed data sources, meaning most basic data operations can be achieved at reasonable speeds.", 
            "title": "Acceleration indices"
        }, 
        {
            "location": "/man/acceleratedarrays/#acceleration-indices-with-acceleratedarrays", 
            "text": "Database systems have evolved many performance tricks over the years to achieve efficiency and scalability. In an environment such as a SQL RDBMS, much effort is put into the creation of an efficient \"query planner\" that will essentially construct a small computer program, ultimately made up of nested loops, searching, mapping and filtering operations, to perform a query. However, the second \"magic\" ingredient used by an RDBMS for performance are secondary \"acceleration indices\", which are pre-calculated views of the data. These views help queries find data that match certain conditions - a hash-map index well let us locate a matching entry in  O (1), or a sort-based index will let us quickly locate  all  the cells less than (or more than) a certain value.  For at least some of the kinds of data analytics performed in Julia, it may be possible to expect the programmer to write and execute their own query plan - that is, to understand their data model, to predict the \"statistics\" regarding the size of and other properties of the data, and to come up with their own rough order of operations that may be efficient. Thus, we may not need to implement a complete query planner to make a viable platform for data analytics in Julia - however, we will absolutely need acceleration indices to perform each elementary operation fast. In the worst case, the programmer would have to construct their own hash-maps and sort-indices (and use them in their own hand-written loops) to obtain peak performance.  The  AcceleratedArrays  package exists to provide a way of attaching secondary acceleration indices to any array in Julia, to speed up operations such as  filter ,  findall ,  group  and  innerjoin  in a transparent and generic way. These acceleration indices can be attached to arbitrary columns (or indeed, entire  Table s). These indices remain silently attached to their parent array until they encounter an operation they can accelerate. The user is free to write  generic  code to execute their query, and the presence of the acceleration index will only act to speed up the resulting specialized algorithm constructed by Julia's compiler.  This system allows for an extensible set of acceleration indices - such as accelerated spatial lookup using a spatial search tree, or an inverted index for searching for words in text fields.   Note: by default, the  innerjoin  operation will construct a hash-based index to perform a join on two unindexed data sources, meaning most basic data operations can be achieved at reasonable speeds.", 
            "title": "Acceleration Indices with AcceleratedArrays"
        }, 
        {
            "location": "/man/design/", 
            "text": "Design overview", 
            "title": "Design"
        }, 
        {
            "location": "/man/design/#design-overview", 
            "text": "", 
            "title": "Design overview"
        }, 
        {
            "location": "/man/reference/", 
            "text": "API Reference\n\n\nTypedTables.jl\n's API is intentially small, relying on existing interfaces to expose powerful and composable functionality.\n\n\nThe reference material can be easily accessed at the REPL, by pressing \n?\n and typing in the name of the command.\n\n\n\n\nConstructing tables\n\n\n#\n\n\nTypedTables.Table\n \n \nType\n.\n\n\nTable(name1 = array1, ...)\n\n\n\n\nCreate a column-storage-based \nTable\n with column names \nname1\n, etc, from arrays \narray1\n, etc. The input arrays \narray1\n, etc, must share the same dimensionality and indices.\n\n\nTable\n itself is an \nAbstractArray\n whose elements are \nNamedTuple\ns of the form \n(name1 = first(array1), ...)\n, etc. Rows of the table are obtained via standard array indexing \ntable[i]\n, and columns via \ntable.name\n.\n\n\nTable\n differs from \nFlexTable\n in that the columns are immutable - you may add, remove, rename and replace entire columns of a \nFlexTable\n, but not a \nTable\n. However, \nTable\n can access and iterate rows in local scope with fast, fully type-inferred code while \nFlexTable\n will be more efficient with a higher-order interface.\n\n\nsource\n\n\n#\n\n\nTypedTables.FlexTable\n \n \nType\n.\n\n\nFlexTable(name1 = array1, ...)\n\n\n\n\nCreate a column-storage-based \nFlexTable\n with column names \nname1\n, etc, from arrays \narray1\n, etc. The input arrays \narray1\n, etc, must share the same dimensionality and indices.\n\n\nFlexTable\n itself is an \nAbstractArray\n whose elements are \nNamedTuple\ns of the form \n(name1 = first(array1), ...)\n, etc. Rows of the table are obtained via standard array indexing \ntable[i]\n, and columns via \ntable.name\n.\n\n\nFlexTable\n differs from \nTable\n in that the columns are mutable - you may add, remove, rename and replace entire columns of a \nFlexTable\n, but not a \nTable\n. However, \nTable\n can access and iterate rows in local scope with fast, fully type-inferred code while \nFlexTable\n will be more efficient with a higher-order interface.\n\n\nsource\n\n\n\n\nReflection\n\n\n#\n\n\nTables.columns\n \n \nFunction\n.\n\n\ncolumns(table::Table)\n\n\n\n\nConvert a \nTable\n into a \nNamedTuple\n of its columns.\n\n\nsource\n\n\ncolumns(dataframe::FlexTable)\n\n\n\n\nConvert a \nFlexTable\n into a \nNamedTuple\n of its columns.\n\n\nsource\n\n\n#\n\n\nTypedTables.columnnames\n \n \nFunction\n.\n\n\ncolumnnames(table)\n\n\n\n\nReturn a tuple of the column names of a \nTable\n.\n\n\nsource\n\n\ncolumnnames(table)\n\n\n\n\nReturn a tuple of the column names of a \nTable\n.\n\n\nsource\n\n\n\n\nConvenience macros\n\n\nThese macros return \nfunctions\n that can be applied to tables and rows.\n\n\n#\n\n\nTypedTables.@Compute\n \n \nMacro\n.\n\n\n@Compute(...)\n\n\n\n\nThe \n@Compute\n macro returns a function which performs a calculation on the properties of an object, such as a \nNamedTuple\n.\n\n\nThe input expression is standard Julia code, with \n$\n prepended to property names. For example. if you want to refer to a property named \na\n then use \n$a\n in the expression.\n\n\nExample\n\n\njulia\n nt = (a = 1, b = 2.0, c = false)\n(a = 1, b = 2.0, c = false)\n\njulia\n @Compute($a + $b)(nt)\n3.0\n\n\n\n\nsource\n\n\n#\n\n\nTypedTables.@Select\n \n \nMacro\n.\n\n\n@Select(...)\n\n\n\n\nThe \n@Select\n macro returns a function which performs an arbitrary transformation of the properties of an object, such as a \nNamedTuple\n.\n\n\nThe input expression is a comma-seperated list of \nlhs = rhs\n pairs. The \nlhs\n is the name of the new property to calculate. The \nrhs is  standard Julia code, with\n:(#= none:1 =# @cmd \" prepended to input property names. For example. if you want to rename an input property \")a\nto be called\nb\n, use\n@Select(b = :a)`.\n\n\nAs a special case, if a property is to be simply replicated the \n= rhs\n part can be dropped, for example \n@Select(a)\n is synomous with \n@Select(a = $a)\n.\n\n\nExample\n\n\njulia\n nt = (a = 1, b = 2.0, c = false)\n(a = 1, b = 2.0, c = false)\n\njulia\n @Select(a, sum_a_b = $a + $b)(nt)\n(a = 1, sum_a_b = 3.0)\n\n\n\n\nsource", 
            "title": "API reference"
        }, 
        {
            "location": "/man/reference/#api-reference", 
            "text": "TypedTables.jl 's API is intentially small, relying on existing interfaces to expose powerful and composable functionality.  The reference material can be easily accessed at the REPL, by pressing  ?  and typing in the name of the command.", 
            "title": "API Reference"
        }, 
        {
            "location": "/man/reference/#constructing-tables", 
            "text": "#  TypedTables.Table     Type .  Table(name1 = array1, ...)  Create a column-storage-based  Table  with column names  name1 , etc, from arrays  array1 , etc. The input arrays  array1 , etc, must share the same dimensionality and indices.  Table  itself is an  AbstractArray  whose elements are  NamedTuple s of the form  (name1 = first(array1), ...) , etc. Rows of the table are obtained via standard array indexing  table[i] , and columns via  table.name .  Table  differs from  FlexTable  in that the columns are immutable - you may add, remove, rename and replace entire columns of a  FlexTable , but not a  Table . However,  Table  can access and iterate rows in local scope with fast, fully type-inferred code while  FlexTable  will be more efficient with a higher-order interface.  source  #  TypedTables.FlexTable     Type .  FlexTable(name1 = array1, ...)  Create a column-storage-based  FlexTable  with column names  name1 , etc, from arrays  array1 , etc. The input arrays  array1 , etc, must share the same dimensionality and indices.  FlexTable  itself is an  AbstractArray  whose elements are  NamedTuple s of the form  (name1 = first(array1), ...) , etc. Rows of the table are obtained via standard array indexing  table[i] , and columns via  table.name .  FlexTable  differs from  Table  in that the columns are mutable - you may add, remove, rename and replace entire columns of a  FlexTable , but not a  Table . However,  Table  can access and iterate rows in local scope with fast, fully type-inferred code while  FlexTable  will be more efficient with a higher-order interface.  source", 
            "title": "Constructing tables"
        }, 
        {
            "location": "/man/reference/#reflection", 
            "text": "#  Tables.columns     Function .  columns(table::Table)  Convert a  Table  into a  NamedTuple  of its columns.  source  columns(dataframe::FlexTable)  Convert a  FlexTable  into a  NamedTuple  of its columns.  source  #  TypedTables.columnnames     Function .  columnnames(table)  Return a tuple of the column names of a  Table .  source  columnnames(table)  Return a tuple of the column names of a  Table .  source", 
            "title": "Reflection"
        }, 
        {
            "location": "/man/reference/#convenience-macros", 
            "text": "These macros return  functions  that can be applied to tables and rows.  #  TypedTables.@Compute     Macro .  @Compute(...)  The  @Compute  macro returns a function which performs a calculation on the properties of an object, such as a  NamedTuple .  The input expression is standard Julia code, with  $  prepended to property names. For example. if you want to refer to a property named  a  then use  $a  in the expression.  Example  julia  nt = (a = 1, b = 2.0, c = false)\n(a = 1, b = 2.0, c = false)\n\njulia  @Compute($a + $b)(nt)\n3.0  source  #  TypedTables.@Select     Macro .  @Select(...)  The  @Select  macro returns a function which performs an arbitrary transformation of the properties of an object, such as a  NamedTuple .  The input expression is a comma-seperated list of  lhs = rhs  pairs. The  lhs  is the name of the new property to calculate. The  rhs is  standard Julia code, with :(#= none:1 =# @cmd \" prepended to input property names. For example. if you want to rename an input property \")a to be called b , use @Select(b = :a)`.  As a special case, if a property is to be simply replicated the  = rhs  part can be dropped, for example  @Select(a)  is synomous with  @Select(a = $a) .  Example  julia  nt = (a = 1, b = 2.0, c = false)\n(a = 1, b = 2.0, c = false)\n\njulia  @Select(a, sum_a_b = $a + $b)(nt)\n(a = 1, sum_a_b = 3.0)  source", 
            "title": "Convenience macros"
        }
    ]
}