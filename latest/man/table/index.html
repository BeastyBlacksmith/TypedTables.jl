<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Andy Ferris">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Table - TypedTables.jl</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  <link href="../../assets/Documenter.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Table";
    var mkdocs_page_input_path = "man/table.md";
    var mkdocs_page_url = "/man/table/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> TypedTables.jl</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Table types</span>
    <ul class="subnav">
                <li class=" current">
                    
    <a class="current" href="./">Table</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#table">Table</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#what-is-a-table">What is a Table?</a></li>
        
            <li><a class="toctree-l4" href="#why-use-a-table">Why use a Table?</a></li>
        
            <li><a class="toctree-l4" href="#creating-tables">Creating Tables</a></li>
        
            <li><a class="toctree-l4" href="#accessing-data-stored-in-tables">Accessing data stored in Tables</a></li>
        
            <li><a class="toctree-l4" href="#comparison-with-a-dataframe">Comparison with a DataFrame</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../flextable/">FlexTable</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Basic data manipulation</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../map/">Mapping data</a>
                </li>
                <li class="">
                    
    <a class="" href="../filter/">Finding data</a>
                </li>
                <li class="">
                    
    <a class="" href="../reduce/">Reducing data</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Grouping and joining data</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../group/">Groupind data</a>
                </li>
                <li class="">
                    
    <a class="" href="../group/">Joining data</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Storing and representing data</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../data/">Data representation</a>
                </li>
                <li class="">
                    
    <a class="" href="../acceleratedarrays/">Acceleration indices</a>
                </li>
                <li class="">
                    
    <a class="" href="../io/">Input and output</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">TypedTables.jl</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Table types &raquo;</li>
        
      
    
    <li>Table</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/FugroRoames/TypedTables.jl/edit/master/docs/man/table.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p><a id='Table-1'></a></p>
<h1 id="table">Table</h1>
<p>It's simple to get started and create a table!</p>
<pre><code class="julia">julia&gt; using TypedTables

julia&gt; t = Table(a = [1, 2, 3], b = [2.0, 4.0, 6.0])
Table with 2 columns and 3 rows:
     a  b
   ┌───────
 1 │ 1  2.0
 2 │ 2  4.0
 3 │ 3  6.0

julia&gt; t[1]  # Get first row
(a = 1, b = 2.0)

julia&gt; t.a  # Get column `a`
3-element Array{Int64,1}:
 1
 2
 3
</code></pre>

<p><a id='What-is-a-Table?-1'></a></p>
<h2 id="what-is-a-table">What is a <code>Table</code>?</h2>
<p>Internally, a <code>Table</code> stores a (named) tuple of arrays, and is a convenient structure for column-based storage of tabular data.</p>
<p>Externally. a <code>Table</code> presents itself as an array of named tuples. That is, each row of the table is represented as one of Julia's new <code>NamedTuple</code>s, which are easy to use and highly efficient.</p>
<p>Thus, manipulating data as a <code>Table</code> is as easy as manipulating arrays and named tuples - which is something Julia was specifically designed to make simple, efficient and <em>fun</em>.</p>
<p><code>Table</code>s (and their columns) may be an <code>AbstractArray</code> of any dimensionality. This let's you take advantage of Julia's powerful array functionality, such as multidimensional broadcasting. Each column must be an array of the same dimensionality and size of the other columns.</p>
<p><a id='Why-use-a-Table?-1'></a></p>
<h2 id="why-use-a-table">Why use a <code>Table</code>?</h2>
<p>Two words: productivity and speed.</p>
<p><em>TypedTables.jl</em> aims to introduce very few concepts, with minimal learning curve to let you manipulate tabular data. The <code>Table</code> type is a simple wrapper over columns and presents the well-known and extremely productive <code>AbstractArray</code> interface. If you are familiar with arrays and named tuples, you should be able to write your data analytics with a <code>Table</code>.</p>
<p>However, it would be of little use if the data container was inherently slow, or if using the container was subject to traps and pitfalls where performance falls of a cliff if the programmer uses an otherwise-idiomatic pattern. In this case, <code>for</code> loops over the rows of a <code>Table</code> are possible at the speed of hand-written code in a statically compiled language such as C, because the compiler is fully aware of the types of each column. Thus, users can write generic functions using a mixture of hand-written loops, calls to functions such as <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>group</code> and <code>innerjoin</code>, as well as high-level interfaces provided by packages such as <a href="https://github.com/queryverse/Query.jl"><em>Query.jl</em></a> - and still obtain optimal performance.</p>
<p>Finally, since <code>Table</code> is unoppinionated about the underlying array storage (and acts more as a convenient metaprogramming layer), the arrays represent each column might have rather distinct properties:</p>
<ul>
<li>Missing values can be modelled by <code>missing</code> and by having columns of element type <code>Union{T, Missing}</code>.</li>
<li>Typical <code>Array</code>-based columns represent continugous chunks of memory, and can be <a href="https://docs.julialang.org/en/v1/stdlib/Mmap/index.html">memory-mapped</a> from disk for a simple way of doing out-of-core analytics.</li>
<li>Acceleration indices can be attached to columns using the <a href="https://github.com/andyferris/AcceleratedArrays.jl">AcceleratedArrays</a> package, speeding up searches and joins.</li>
<li>Some data can be stored in compressed form using <a href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/index.html">sparse arrays</a>, <a href="http://juliadata.github.io/CategoricalArrays.jl/latest/using.html">categorical arrays</a>, and so-on.</li>
<li>Columns could be stored and processed on a GPU with <a href="https://github.com/JuliaGPU/GPUArrays.jl">GPU-backed array</a> using <a href="https://github.com/JuliaGPU/CuArrays.jl">CUDA</a>, <a href="https://github.com/JuliaGPU/CLArrays.jl">OpenCL</a>, <a href="https://github.com/JuliaComputing/ArrayFire.jl">ArrayFire</a>, etc.</li>
<li>Columns might be distributed and processed in parallel over multiple machines with <a href="https://github.com/JuliaParallel/DistributedArrays.jl">DistributedArrays</a> or between multiple processes with <a href="https://docs.julialang.org/en/v1/stdlib/SharedArrays/index.html"><code>SharedArrays</code></a>.</li>
<li>In extreme cases, tables with a small, fixed number of rows might be most efficient represented with a <a href="https://github.com/JuliaArrays/StaticArrays.jl">statically sized array</a>.</li>
</ul>
<p>In each case, the user will be able to use much the same interface (and code) to perform their transformations. In the background, Julia's compiler will create specialized, performant machine code, for whichever backing array you choose.</p>
<p><a id='Creating-Tables-1'></a></p>
<h2 id="creating-tables">Creating <code>Table</code>s</h2>
<p>The easiest way to create a table from columns is with keyword arguments, such as</p>
<pre><code class="julia">julia&gt; t = Table(name = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;], age = [25, 42, 37])
Table with 2 columns and 3 rows:
     name     age
   ┌─────────────
 1 │ Alice    25
 2 │ Bob      42
 3 │ Charlie  37
</code></pre>

<p>The constructor will equally accept a <code>NamedTuple</code> of columns, as <code>Table((name = ["Alice", "Bob", "Charlie"], age = [25, 42, 37]))</code> (note the extra brackets).</p>
<p>Also, one can easily convert the row-storage-based vector of named tuples into columnar storage using the <code>Table</code> constructor:</p>
<pre><code class="julia">julia&gt; Table([(name = &quot;Alice&quot;, age = 25), (name = &quot;Bob&quot;, age = 42), (name = &quot;Charlie&quot;, age = 37)])
Table with 2 columns and 3 rows:
     name     age
   ┌─────────────
 1 │ Alice    25
 2 │ Bob      42
 3 │ Charlie  37
</code></pre>

<p><a id='Accessing-data-stored-in-Tables-1'></a></p>
<h2 id="accessing-data-stored-in-tables">Accessing data stored in <code>Table</code>s</h2>
<p><a id='Row-access-1'></a></p>
<h3 id="row-access">Row access</h3>
<p>A single row of a <code>Table</code> is just a <code>NamedTuple</code>, which is easy to access.</p>
<pre><code class="julia">julia&gt; t[1]
(name = &quot;Alice&quot;, age = 25)
</code></pre>

<p>Multiple rows can be indexed similarly to standard arrays in Julia:</p>
<pre><code>julia&gt; t[2:3]
Table with 2 columns and 2 rows:
     name     age
   ┌─────────────
 1 │ Bob      42
 2 │ Charlie  37
</code></pre>

<p>One can interrogate the <code>length</code>, <code>size</code> or <code>axes</code> of a <code>Table</code> just like any other <code>AbstractArray</code>:</p>
<pre><code>julia&gt; length(t)
3

julia&gt; size(t)
(3,)
</code></pre>

<p>(Note: the number of columns does not participate in the <code>size</code>.)</p>
<p>Finally, if the backing arrays support mutation, rows can be mutated with <code>setindex!</code></p>
<pre><code>julia&gt; t[3] = (name = Charlie, name = 38)  # Charlie had a birthday
Table with 2 columns and 3 rows:
     name     age
   ┌─────────────
 1 │ Alice    25
 2 │ Bob      42
 3 │ Charlie  38
</code></pre>

<p>Similarly, rows can be added or removed with <code>push!</code>, <code>pop!</code> and <a href="https://docs.julialang.org/en/v1.0/base/collections/#Dequeues-1">so-on</a>.</p>
<p><a id='Column-access-1'></a></p>
<h3 id="column-access">Column access</h3>
<p>A single column can be recovered using Julia's new <code>getproperty</code> syntax using the <code>.</code> operator.</p>
<pre><code class="julia">julia&gt; t.name
3-element Array{String,1}:
 &quot;Alice&quot;  
 &quot;Bob&quot;    
 &quot;Charlie&quot;
</code></pre>

<p>Currently, the simplest way to extract more than one column is to construct a brand new table out of the columns (as in <code>table2 = Table(column1 = table1.column1, column2 = table1.column2, ...)</code>).</p>
<p>The columns of a <code>Table</code> can be accessed directly as a <code>NamedTuple</code> of arrays using the <code>columns</code> function.</p>
<pre><code class="julia">julia&gt; columns(t)
(name = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;], age = [25, 42, 37])
</code></pre>

<p>There is a <code>columnnames</code> function for getting the names of the columns:</p>
<pre><code class="julia">julia&gt; columnnames(t)
(:name, :age)
</code></pre>

<p>Note that the column names are Julia <code>Symbol</code>s, which are <a href="https://en.wikipedia.org/wiki/String_interning">interned strings</a> tracked by the compiler.</p>
<p>Finally, the values contained in entire columns may be updated using <code>.=</code>, such as <code>t.age .= 0</code> or <code>t.age .= [26, 43, 38]</code>. Note that skipping the <code>.</code> in <code>.=</code>, such as <code>t.age = [26, 43, 38]</code>, will produce an error because the references to the column <em>containers</em> are immutable (if you wish to replace the entire <em>container</em> of a column, you may need to use a <code>FlexTable</code>).</p>
<p><a id='Cell-access-1'></a></p>
<h3 id="cell-access">Cell access</h3>
<p>From the above, we can see two identical ways to get a cell of data:</p>
<pre><code class="julia">julia&gt; t[1].name
&quot;Alice&quot;

julia&gt; t.name[1]
&quot;Alice&quot;
</code></pre>

<p>While Julia's compiler will elide a lot of unnecessary code, you may find it faster to index individual cells of the table using the second option (to avoid fetching and constructing the <em>entire</em> named tuple of a row as an intermediate step).</p>
<p>Similarly, the value of a cell can be updated via <code>setindex!</code>, for example using the syntax <code>t.name[1] = "Alicia"</code>. Note that the syntax <code>t[1].name = "Alicia"</code> will error because you are trying to mutate <code>t[1]</code>, which is an immutable <em>copy</em> of the data (completely independent from <code>t</code>).</p>
<p><a id='Comparison-with-a-DataFrame-1'></a></p>
<h2 id="comparison-with-a-dataframe">Comparison with a <code>DataFrame</code></h2>
<p>For those with experience using the <a href="https://github.com/JuliaData/DataFrames.jl"><em>DataFrames.jl</em></a> package, this comparison may be useful:</p>
<ul>
<li>The columns stored in a <code>Table</code> are immutable - you cannot add, remove or rename a column. However, it is very cheap to create a new table with different columns, encouraging a functional programming style to deal with your outer data structure. (See also <code>FlexTable</code> for a more flexible alternative). For compison, this is a similar approach to <a href="https://github.com/JuliaComputing/IndexedTables.jl"><em>IndexedTables</em></a> and <a href="https://github.com/JuliaComputing/JuliaDB.jl"><em>JuliaDB</em></a>, while <em>DataFrames</em> uses an untyped vector of columns.</li>
<li>The columns themselves may be mutable. You may modify the data in one-or-more columns, and add or remove rows as necessary. Thus, operations on the <em>data</em> (not the data <em>structure</em>) can follow an imperative form, if desired.</li>
<li>The types of the columns are known to the compiler, making direct operations like iteration of the rows of a <code>Table</code> very fast. The programmer is free to write a combination of low-level <code>for</code> loops, use operations like <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>group</code> or <code>innerjoin</code>, or to use a high-level query interface such as <em>Query.jl</em> - all with the high performance you would expect of a statically compiled language.</li>
<li>Conversely, the Julia compiler spends effort tracking the names and types of all the columns of the table. If you have a very large number of columns (many hundreds), <code>Table</code> may not be a suitable data structure (here, <code>DataFrame</code>s dynamically sized and typed vector of columns may be more appropriate).</li>
<li><code>Table</code>s can be an array of any dimensionality.</li>
<li>Unlike a <code>DataFrame</code>, you cannot access a single cell in a single <code>getindex</code> call (you should first extract a column, and index a cell from that column). Similarly, the number of columns does not participate in the <code>size</code> or <code>length</code> of a <code>Table</code>.</li>
</ul>
<p>A good litimus test of whether a statically-compiled <code>Table</code> or a dynamic approach like <em>DataFrames</em> is more appropriate, is to see whether the written <strong>code</strong> tends to refer to the columns by name, or whether the column names are more dynamic (and, for example, iteration over columns is required).</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../flextable/" class="btn btn-neutral float-right" title="FlexTable">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../.." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/FugroRoames/TypedTables.jl/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../.." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../flextable/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
      <script src="../../assets/mathjaxhelper.js"></script>
      <script src="../../search/require.js"></script>
      <script src="../../search/search.js"></script>

</body>
</html>
