{
    "docs": [
        {
            "location": "/", 
            "text": "TypedTables.jl\n\n\nSimple, column-based storage for data analysis in Julia.\n\n\n\n\nIntroduction\n\n\nTypedTables.jl\n provides two column-based storage containers: \nTable\n and \nFlexTable\n, both of which represent an array of \nNamedTuple\ns. This package is designed to be lightweight, easy-to-use and fast, and presents a very minimal new interface to learn.\n\n\nData manipulation is possible throught the tools built into Julia (such as \nmap\n, \nfilter\n, and \nreduce\n) and those provide by \nSplitApplyCombine.jl\n (like \ngroup\n and \ninnerjoin\n). You can speed up data analysis tasks with acceleration indices, by using the \nAcceleratedArrays.jl\n package. This package is integrated the \nTables.jl\n interface, and therefore the rest of the data ecosystem such as \nQuery.jl\n. This documentation includes examples on how to integrate with these packages for a complete data analysis workflow.\n\n\n\n\nInstallation\n\n\nStart Julia 1.0, and press \n]\n to enter \"package\" mode. Then type:\n\n\npkg\n add TypedTables\n\n\n\n\nThat's it!\n\n\n\n\nTable Types\n\n\n\n\nTable\n\n\nFlexTable\n\n\n\n\n\n\nBasic data manipulation\n\n\n\n\nMapping rows of data\n\n\nFinding data\n\n\nReducing data\n\n\n\n\n\n\nGrouping and joining data\n\n\n\n\nGrouping data\n\n\nJoining data\n\n\n\n\n\n\nRepresenting data and acceleration indices\n\n\n\n\nAcceleration Indices with \nAcceleratedArrays\n\n\nRepresenting and storing data\n\n\n\n\n\n\nInput and Output\n\n\n\n\nInput and output", 
            "title": "Home"
        }, 
        {
            "location": "/#typedtablesjl", 
            "text": "Simple, column-based storage for data analysis in Julia.", 
            "title": "TypedTables.jl"
        }, 
        {
            "location": "/#introduction", 
            "text": "TypedTables.jl  provides two column-based storage containers:  Table  and  FlexTable , both of which represent an array of  NamedTuple s. This package is designed to be lightweight, easy-to-use and fast, and presents a very minimal new interface to learn.  Data manipulation is possible throught the tools built into Julia (such as  map ,  filter , and  reduce ) and those provide by  SplitApplyCombine.jl  (like  group  and  innerjoin ). You can speed up data analysis tasks with acceleration indices, by using the  AcceleratedArrays.jl  package. This package is integrated the  Tables.jl  interface, and therefore the rest of the data ecosystem such as  Query.jl . This documentation includes examples on how to integrate with these packages for a complete data analysis workflow.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "Start Julia 1.0, and press  ]  to enter \"package\" mode. Then type:  pkg  add TypedTables  That's it!", 
            "title": "Installation"
        }, 
        {
            "location": "/#table-types", 
            "text": "Table  FlexTable", 
            "title": "Table Types"
        }, 
        {
            "location": "/#basic-data-manipulation", 
            "text": "Mapping rows of data  Finding data  Reducing data", 
            "title": "Basic data manipulation"
        }, 
        {
            "location": "/#grouping-and-joining-data", 
            "text": "Grouping data  Joining data", 
            "title": "Grouping and joining data"
        }, 
        {
            "location": "/#representing-data-and-acceleration-indices", 
            "text": "Acceleration Indices with  AcceleratedArrays  Representing and storing data", 
            "title": "Representing data and acceleration indices"
        }, 
        {
            "location": "/#input-and-output", 
            "text": "Input and output", 
            "title": "Input and Output"
        }, 
        {
            "location": "/man/table/", 
            "text": "Table\n\n\nIt's simple to get started and create a table!\n\n\njulia\n using TypedTables\n\njulia\n t = Table(a = [1, 2, 3], b = [2.0, 4.0, 6.0])\nTable with 2 columns and 3 rows:\n     a  b\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 1  2.0\n 2 \u2502 2  4.0\n 3 \u2502 3  6.0\n\njulia\n t[1]  # Get first row\n(a = 1, b = 2.0)\n\njulia\n t.a  # Get column `a`\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\n\n\n\n\n\nWhat is a \nTable\n?\n\n\nInternally, a \nTable\n stores a (named) tuple of arrays, and is a convenient structure for column-based storage of tabular data.\n\n\nExternally. a \nTable\n presents itself as an array of named tuples. That is, each row of the table is represented as one of Julia's new \nNamedTuple\ns, which are easy to use and highly efficient.\n\n\nThus, manipulating data as a \nTable\n is as easy as manipulating arrays and named tuples - which is something Julia was specifically designed to make simple, efficient and \nfun\n.\n\n\nTable\ns (and their columns) may be an \nAbstractArray\n of any dimensionality. This let's you take advantage of Julia's powerful array functionality, such as multidimensional broadcasting. Each column must be an array of the same dimensionality and size of the other columns.\n\n\n\n\nWhy use a \nTable\n?\n\n\nTwo words: productivity and speed.\n\n\nTypedTables.jl\n aims to introduce very few concepts, with minimal learning curve to let you manipulate tabular data. The \nTable\n type is a simple wrapper over columns and presents the well-known and extremely productive \nAbstractArray\n interface. If you are familiar with arrays and named tuples, you should be able to write your data analytics with a \nTable\n.\n\n\nHowever, it would be of little use if the data container was inherently slow, or if using the container was subject to traps and pitfalls where performance falls of a cliff if the programmer uses an otherwise-idiomatic pattern. In this case, \nfor\n loops over the rows of a \nTable\n are possible at the speed of hand-written code in a statically compiled language such as C, because the compiler is fully aware of the types of each column. Thus, users can write generic functions using a mixture of hand-written loops, calls to functions such as \nmap\n, \nfilter\n, \nreduce\n, \ngroup\n and \ninnerjoin\n, as well as high-level interfaces provided by packages such as \nQuery.jl\n - and still obtain optimal performance.\n\n\nFinally, since \nTable\n is unoppinionated about the underlying array storage (and acts more as a convenient metaprogramming layer), the arrays represent each column might have rather distinct properties:\n\n\n\n\nMissing values can be modelled by \nmissing\n and by having columns of element type \nUnion{T, Missing}\n.\n\n\nTypical \nArray\n-based columns represent continugous chunks of memory, and can be \nmemory-mapped\n from disk for a simple way of doing out-of-core analytics.\n\n\nAcceleration indices can be attached to columns using the \nAcceleratedArrays\n package, speeding up searches and joins.\n\n\nSome data can be stored in compressed form using \nsparse arrays\n, \ncategorical arrays\n, and so-on.\n\n\nColumns could be stored and processed on a GPU with \nGPU-backed array\n using \nCUDA\n, \nOpenCL\n, \nArrayFire\n, etc.\n\n\nColumns might be distributed and processed in parallel over multiple machines with \nDistributedArrays\n or between multiple processes with \nSharedArrays\n.\n\n\nIn extreme cases, tables with a small, fixed number of rows might be most efficient represented with a \nstatically sized array\n.\n\n\n\n\nIn each case, the user will be able to use much the same interface (and code) to perform their transformations. In the background, Julia's compiler will create specialized, performant machine code, for whichever backing array you choose.\n\n\n\n\nCreating \nTable\ns\n\n\nThe easiest way to create a table from columns is with keyword arguments, such as\n\n\njulia\n t = Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\n\n\n\nThe constructor will equally accept a \nNamedTuple\n of columns, as \nTable((name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37]))\n (note the extra brackets).\n\n\nAlso, one can easily convert the row-storage-based vector of named tuples into columnar storage using the \nTable\n constructor:\n\n\njulia\n Table([(name = \nAlice\n, age = 25), (name = \nBob\n, age = 42), (name = \nCharlie\n, age = 37)])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\n\n\n\n\n\nAccessing data stored in \nTable\ns\n\n\n\n\nRow access\n\n\nA single row of a \nTable\n is just a \nNamedTuple\n, which is easy to access.\n\n\njulia\n t[1]\n(name = \nAlice\n, age = 25)\n\n\n\n\nMultiple rows can be indexed similarly to standard arrays in Julia:\n\n\njulia\n t[2:3]\nTable with 2 columns and 2 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob      42\n 2 \u2502 Charlie  37\n\n\n\n\nOne can interrogate the \nlength\n, \nsize\n or \naxes\n of a \nTable\n just like any other \nAbstractArray\n:\n\n\njulia\n length(t)\n3\n\njulia\n size(t)\n(3,)\n\n\n\n\n(Note: the number of columns does not participate in the \nsize\n.)\n\n\nFinally, if the backing arrays support mutation, rows can be mutated with \nsetindex!\n\n\njulia\n t[3] = (name = Charlie, name = 38)  # Charlie had a birthday\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  38\n\n\n\n\nSimilarly, rows can be added or removed with \npush!\n, \npop!\n and \nso-on\n.\n\n\n\n\nColumn access\n\n\nA single column can be recovered using Julia's new \ngetproperty\n syntax using the \n.\n operator.\n\n\njulia\n t.name\n3-element Array{String,1}:\n \nAlice\n  \n \nBob\n    \n \nCharlie\n\n\n\n\n\nCurrently, the simplest way to extract more than one column is to construct a brand new table out of the columns (as in \ntable2 = Table(column1 = table1.column1, column2 = table1.column2, ...)\n).\n\n\nThe columns of a \nTable\n can be accessed directly as a \nNamedTuple\n of arrays using the \ncolumns\n function.\n\n\njulia\n columns(t)\n(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\n\n\n\n\nThere is a \ncolumnnames\n function for getting the names of the columns:\n\n\njulia\n columnnames(t)\n(:name, :age)\n\n\n\n\nNote that the column names are Julia \nSymbol\ns, which are \ninterned strings\n tracked by the compiler.\n\n\nFinally, the values contained in entire columns may be updated using \n.=\n, such as \nt.age .= 0\n or \nt.age .= [26, 43, 38]\n. Note that skipping the \n.\n in \n.=\n, such as \nt.age = [26, 43, 38]\n, will produce an error because the references to the column \ncontainers\n are immutable (if you wish to replace the entire \ncontainer\n of a column, you may need to use a \nFlexTable\n).\n\n\n\n\nCell access\n\n\nFrom the above, we can see two identical ways to get a cell of data:\n\n\njulia\n t[1].name\n\nAlice\n\n\njulia\n t.name[1]\n\nAlice\n\n\n\n\n\nWhile Julia's compiler will elide a lot of unnecessary code, you may find it faster to index individual cells of the table using the second option (to avoid fetching and constructing the \nentire\n named tuple of a row as an intermediate step).\n\n\nSimilarly, the value of a cell can be updated via \nsetindex!\n, for example using the syntax \nt.name[1] = \"Alicia\"\n. Note that the syntax \nt[1].name = \"Alicia\"\n will error because you are trying to mutate \nt[1]\n, which is an immutable \ncopy\n of the data (completely independent from \nt\n).\n\n\n\n\nComparison with a \nDataFrame\n\n\nFor those with experience using the \nDataFrames.jl\n package, this comparison may be useful:\n\n\n\n\nThe columns stored in a \nTable\n are immutable - you cannot add, remove or rename a column. However, it is very cheap to create a new table with different columns, encouraging a functional programming style to deal with your outer data structure. (See also \nFlexTable\n for a more flexible alternative). For compison, this is a similar approach to \nIndexedTables\n and \nJuliaDB\n, while \nDataFrames\n uses an untyped vector of columns.\n\n\nThe columns themselves may be mutable. You may modify the data in one-or-more columns, and add or remove rows as necessary. Thus, operations on the \ndata\n (not the data \nstructure\n) can follow an imperative form, if desired.\n\n\nThe types of the columns are known to the compiler, making direct operations like iteration of the rows of a \nTable\n very fast. The programmer is free to write a combination of low-level \nfor\n loops, use operations like \nmap\n, \nfilter\n, \nreduce\n, \ngroup\n or \ninnerjoin\n, or to use a high-level query interface such as \nQuery.jl\n - all with the high performance you would expect of a statically compiled language.\n\n\nConversely, the Julia compiler spends effort tracking the names and types of all the columns of the table. If you have a very large number of columns (many hundreds), \nTable\n may not be a suitable data structure (here, \nDataFrame\ns dynamically sized and typed vector of columns may be more appropriate).\n\n\nTable\ns can be an array of any dimensionality.\n\n\nUnlike a \nDataFrame\n, you cannot access a single cell in a single \ngetindex\n call (you should first extract a column, and index a cell from that column). Similarly, the number of columns does not participate in the \nsize\n or \nlength\n of a \nTable\n.\n\n\n\n\nA good litimus test of whether a statically-compiled \nTable\n or a dynamic approach like \nDataFrames\n is more appropriate, is to see whether the written \ncode\n tends to refer to the columns by name, or whether the column names are more dynamic (and, for example, iteration over columns is required).", 
            "title": "Table"
        }, 
        {
            "location": "/man/table/#table", 
            "text": "It's simple to get started and create a table!  julia  using TypedTables\n\njulia  t = Table(a = [1, 2, 3], b = [2.0, 4.0, 6.0])\nTable with 2 columns and 3 rows:\n     a  b\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 1  2.0\n 2 \u2502 2  4.0\n 3 \u2502 3  6.0\n\njulia  t[1]  # Get first row\n(a = 1, b = 2.0)\n\njulia  t.a  # Get column `a`\n3-element Array{Int64,1}:\n 1\n 2\n 3", 
            "title": "Table"
        }, 
        {
            "location": "/man/table/#what-is-a-table", 
            "text": "Internally, a  Table  stores a (named) tuple of arrays, and is a convenient structure for column-based storage of tabular data.  Externally. a  Table  presents itself as an array of named tuples. That is, each row of the table is represented as one of Julia's new  NamedTuple s, which are easy to use and highly efficient.  Thus, manipulating data as a  Table  is as easy as manipulating arrays and named tuples - which is something Julia was specifically designed to make simple, efficient and  fun .  Table s (and their columns) may be an  AbstractArray  of any dimensionality. This let's you take advantage of Julia's powerful array functionality, such as multidimensional broadcasting. Each column must be an array of the same dimensionality and size of the other columns.", 
            "title": "What is a Table?"
        }, 
        {
            "location": "/man/table/#why-use-a-table", 
            "text": "Two words: productivity and speed.  TypedTables.jl  aims to introduce very few concepts, with minimal learning curve to let you manipulate tabular data. The  Table  type is a simple wrapper over columns and presents the well-known and extremely productive  AbstractArray  interface. If you are familiar with arrays and named tuples, you should be able to write your data analytics with a  Table .  However, it would be of little use if the data container was inherently slow, or if using the container was subject to traps and pitfalls where performance falls of a cliff if the programmer uses an otherwise-idiomatic pattern. In this case,  for  loops over the rows of a  Table  are possible at the speed of hand-written code in a statically compiled language such as C, because the compiler is fully aware of the types of each column. Thus, users can write generic functions using a mixture of hand-written loops, calls to functions such as  map ,  filter ,  reduce ,  group  and  innerjoin , as well as high-level interfaces provided by packages such as  Query.jl  - and still obtain optimal performance.  Finally, since  Table  is unoppinionated about the underlying array storage (and acts more as a convenient metaprogramming layer), the arrays represent each column might have rather distinct properties:   Missing values can be modelled by  missing  and by having columns of element type  Union{T, Missing} .  Typical  Array -based columns represent continugous chunks of memory, and can be  memory-mapped  from disk for a simple way of doing out-of-core analytics.  Acceleration indices can be attached to columns using the  AcceleratedArrays  package, speeding up searches and joins.  Some data can be stored in compressed form using  sparse arrays ,  categorical arrays , and so-on.  Columns could be stored and processed on a GPU with  GPU-backed array  using  CUDA ,  OpenCL ,  ArrayFire , etc.  Columns might be distributed and processed in parallel over multiple machines with  DistributedArrays  or between multiple processes with  SharedArrays .  In extreme cases, tables with a small, fixed number of rows might be most efficient represented with a  statically sized array .   In each case, the user will be able to use much the same interface (and code) to perform their transformations. In the background, Julia's compiler will create specialized, performant machine code, for whichever backing array you choose.", 
            "title": "Why use a Table?"
        }, 
        {
            "location": "/man/table/#creating-tables", 
            "text": "The easiest way to create a table from columns is with keyword arguments, such as  julia  t = Table(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37  The constructor will equally accept a  NamedTuple  of columns, as  Table((name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37]))  (note the extra brackets).  Also, one can easily convert the row-storage-based vector of named tuples into columnar storage using the  Table  constructor:  julia  Table([(name =  Alice , age = 25), (name =  Bob , age = 42), (name =  Charlie , age = 37)])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37", 
            "title": "Creating Tables"
        }, 
        {
            "location": "/man/table/#accessing-data-stored-in-tables", 
            "text": "", 
            "title": "Accessing data stored in Tables"
        }, 
        {
            "location": "/man/table/#row-access", 
            "text": "A single row of a  Table  is just a  NamedTuple , which is easy to access.  julia  t[1]\n(name =  Alice , age = 25)  Multiple rows can be indexed similarly to standard arrays in Julia:  julia  t[2:3]\nTable with 2 columns and 2 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob      42\n 2 \u2502 Charlie  37  One can interrogate the  length ,  size  or  axes  of a  Table  just like any other  AbstractArray :  julia  length(t)\n3\n\njulia  size(t)\n(3,)  (Note: the number of columns does not participate in the  size .)  Finally, if the backing arrays support mutation, rows can be mutated with  setindex!  julia  t[3] = (name = Charlie, name = 38)  # Charlie had a birthday\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  38  Similarly, rows can be added or removed with  push! ,  pop!  and  so-on .", 
            "title": "Row access"
        }, 
        {
            "location": "/man/table/#column-access", 
            "text": "A single column can be recovered using Julia's new  getproperty  syntax using the  .  operator.  julia  t.name\n3-element Array{String,1}:\n  Alice   \n  Bob     \n  Charlie   Currently, the simplest way to extract more than one column is to construct a brand new table out of the columns (as in  table2 = Table(column1 = table1.column1, column2 = table1.column2, ...) ).  The columns of a  Table  can be accessed directly as a  NamedTuple  of arrays using the  columns  function.  julia  columns(t)\n(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])  There is a  columnnames  function for getting the names of the columns:  julia  columnnames(t)\n(:name, :age)  Note that the column names are Julia  Symbol s, which are  interned strings  tracked by the compiler.  Finally, the values contained in entire columns may be updated using  .= , such as  t.age .= 0  or  t.age .= [26, 43, 38] . Note that skipping the  .  in  .= , such as  t.age = [26, 43, 38] , will produce an error because the references to the column  containers  are immutable (if you wish to replace the entire  container  of a column, you may need to use a  FlexTable ).", 
            "title": "Column access"
        }, 
        {
            "location": "/man/table/#cell-access", 
            "text": "From the above, we can see two identical ways to get a cell of data:  julia  t[1].name Alice \n\njulia  t.name[1] Alice   While Julia's compiler will elide a lot of unnecessary code, you may find it faster to index individual cells of the table using the second option (to avoid fetching and constructing the  entire  named tuple of a row as an intermediate step).  Similarly, the value of a cell can be updated via  setindex! , for example using the syntax  t.name[1] = \"Alicia\" . Note that the syntax  t[1].name = \"Alicia\"  will error because you are trying to mutate  t[1] , which is an immutable  copy  of the data (completely independent from  t ).", 
            "title": "Cell access"
        }, 
        {
            "location": "/man/table/#comparison-with-a-dataframe", 
            "text": "For those with experience using the  DataFrames.jl  package, this comparison may be useful:   The columns stored in a  Table  are immutable - you cannot add, remove or rename a column. However, it is very cheap to create a new table with different columns, encouraging a functional programming style to deal with your outer data structure. (See also  FlexTable  for a more flexible alternative). For compison, this is a similar approach to  IndexedTables  and  JuliaDB , while  DataFrames  uses an untyped vector of columns.  The columns themselves may be mutable. You may modify the data in one-or-more columns, and add or remove rows as necessary. Thus, operations on the  data  (not the data  structure ) can follow an imperative form, if desired.  The types of the columns are known to the compiler, making direct operations like iteration of the rows of a  Table  very fast. The programmer is free to write a combination of low-level  for  loops, use operations like  map ,  filter ,  reduce ,  group  or  innerjoin , or to use a high-level query interface such as  Query.jl  - all with the high performance you would expect of a statically compiled language.  Conversely, the Julia compiler spends effort tracking the names and types of all the columns of the table. If you have a very large number of columns (many hundreds),  Table  may not be a suitable data structure (here,  DataFrame s dynamically sized and typed vector of columns may be more appropriate).  Table s can be an array of any dimensionality.  Unlike a  DataFrame , you cannot access a single cell in a single  getindex  call (you should first extract a column, and index a cell from that column). Similarly, the number of columns does not participate in the  size  or  length  of a  Table .   A good litimus test of whether a statically-compiled  Table  or a dynamic approach like  DataFrames  is more appropriate, is to see whether the written  code  tends to refer to the columns by name, or whether the column names are more dynamic (and, for example, iteration over columns is required).", 
            "title": "Comparison with a DataFrame"
        }, 
        {
            "location": "/man/flextable/", 
            "text": "FlexTable\n\n\nThis package defines a second tabular container type, \nFlexTable\n, that is designed to be a more \nflex\nible \ntable\n.\n\n\nThe two primary difference between \nTable\n and \nFlexTable\n are that\n\n\n\n\nThe columns can be mutated - that is, we can add, replace or delete a column.\n\n\nThe compiler cannot track the types or names of the columns.\n\n\n\n\nThus, a \nFlexTable\n provides the same interface as a \nTable\n plus some extra operations. However, the fact that the compiler can no longer statically analyse the names and types of the columns at any given moment of the program means that the element type of a \nFlexTable\n is no more specific than \nNamedTuple\n. Iteration over rows will therefore be slower using \nfor\n loops than for the equivalent \nTable\n - for maximum speed, higher-level functions (like \nmap\n, \nfilter\n, \nreduce\n, \ngroup\n and \ninnerjoin\n) or a high-level DSL (like \nQuery.jl\n) should be utilized.\n\n\nAmongst other things, using \nFlexTable\n might allow you to more easily port your code from another environment where the columns are mutable, such as \nDataFrames.jl\n.\n\n\n\n\nAdding or replacing columns\n\n\nA column can be added by using the \nsetproperty!\n interface (the \n.\n operator).\n\n\njulia\n ft = FlexTable(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nFlexTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia\n ft.sex = [:F, :M, :M];\n\njulia\n ft\nFlexTable with 3 columns and 3 rows:\n     name     age  sex\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25   F\n 2 \u2502 Bob      42   M\n 3 \u2502 Charlie  37   M\n\n\n\n\nThe same syntax is used to replace a column.\n\n\njulia\n ft.sex = [\nfemale\n, \nmale\n, \nmale\n];\n\njulia\n ft\nFlexTable with 3 columns and 3 rows:\n     name     age  sex\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25   female\n 2 \u2502 Bob      42   male\n 3 \u2502 Charlie  37   male", 
            "title": "FlexTable"
        }, 
        {
            "location": "/man/flextable/#flextable", 
            "text": "This package defines a second tabular container type,  FlexTable , that is designed to be a more  flex ible  table .  The two primary difference between  Table  and  FlexTable  are that   The columns can be mutated - that is, we can add, replace or delete a column.  The compiler cannot track the types or names of the columns.   Thus, a  FlexTable  provides the same interface as a  Table  plus some extra operations. However, the fact that the compiler can no longer statically analyse the names and types of the columns at any given moment of the program means that the element type of a  FlexTable  is no more specific than  NamedTuple . Iteration over rows will therefore be slower using  for  loops than for the equivalent  Table  - for maximum speed, higher-level functions (like  map ,  filter ,  reduce ,  group  and  innerjoin ) or a high-level DSL (like  Query.jl ) should be utilized.  Amongst other things, using  FlexTable  might allow you to more easily port your code from another environment where the columns are mutable, such as  DataFrames.jl .", 
            "title": "FlexTable"
        }, 
        {
            "location": "/man/flextable/#adding-or-replacing-columns", 
            "text": "A column can be added by using the  setproperty!  interface (the  .  operator).  julia  ft = FlexTable(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nFlexTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia  ft.sex = [:F, :M, :M];\n\njulia  ft\nFlexTable with 3 columns and 3 rows:\n     name     age  sex\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25   F\n 2 \u2502 Bob      42   M\n 3 \u2502 Charlie  37   M  The same syntax is used to replace a column.  julia  ft.sex = [ female ,  male ,  male ];\n\njulia  ft\nFlexTable with 3 columns and 3 rows:\n     name     age  sex\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25   female\n 2 \u2502 Bob      42   male\n 3 \u2502 Charlie  37   male", 
            "title": "Adding or replacing columns"
        }, 
        {
            "location": "/man/map/", 
            "text": "Mapping rows of data\n\n\nSome operations on your data will act by mapping each row of data in a table to a value, or even to new rows (in the case of relational operations). In either case, you are mapping an element of table (which is an array whose elements are rows) to create a new array of computed elements (whose elements may or may not be rows, and thus may or may not be a \nTable\n).\n\n\n\n\nUsing \nmap\n\n\nIn Julia, the idiomatic way to perform such an operation is with the \nmap\n function, which takes a function and an input array.\n\n\nOne very simple example of this is extracting a column, let's say the column called \nname\n from a table of people's names and ages.\n\n\njulia\n t = Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia\n map(row -\n row.name, t)\n3-element Array{String,1}:\n \nAlice\n  \n \nBob\n    \n \nCharlie\n\n\n\n\n\nThis has returned and standard Julia array, which will be a \ncopy\n of the array of the \nname\n column. We could also do a more complicated calculation.\n\n\njulia\n is_old = map(row -\n row.age \n 40, t)\n3-element Array{Bool,1}:\n false\n  true\n false\n\n\n\n\nDepending on your definition of \"old\", we have identified two younger people and one older person - though I suspect that Bob may have a different definition of old than Alice does.\n\n\nOne can also \nmap\n rows, which are \nNamedTuple\ns, to new \nNamedTuples\n, which will naturally result in a new tabular structure. Here is an example where we simply copy the names into a new table (but change the column name to \nfirstname\n):\n\n\njulia\n map(row -\n (firstname = row.name,), t)\nTable with 1 column and 3 rows:\n     firstname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Bob\n 3 \u2502 Charlie\n\n\n\n\nInternally, this is leveraging Julia's \nsimilar\n interface for constructing new arrays: if we are creating something \nsimilar\n to a \nTable\n with an element type that is a \nNamedTuple\n, we get a new \nTable\n. (The columns themselves are also \nsimilar\n to the existing columns, preserving their structure as appropriate). If the output type is not a \nNamedTuple\n, the output array is \nsimilar\n to the first column.\n\n\nPutting this all together, we can create a brand-new table using \nmap\n to manipulate both columns.\n\n\njulia\n map(row -\n (name = row.name, is_old = row.age \n 40), t)\nTable with 2 columns and 3 rows:\n     name     is_old\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    false\n 2 \u2502 Bob      true\n 3 \u2502 Charlie  false\n\n\n\n\n\n\nExplicit \nfor\n loops\n\n\nOne can easily use \nfor\n loops to iterate over your data and perform whatever mapping is required. For example, this loop takes the \nfirst\n character of the elements of the \nname\n column.\n\n\njulia\n function firstletter(t::Table)\n    out = Vector{Char}(undef, length(t))\n\n    for i in 1:length(t)\n        out[i] = first(t.name[i])\n    end\n\n    return out\nend\n\njulia\n firstletter(t)\n3-element Array{Char,1}:\n 'A'\n 'B'\n 'C'\n\n\n\n\nJulia will use the type information it knows about \nt\n to create fast, compiled code. (Pro tip: to make the above loop \noptimal\n, adding an \n@inbounds\n annotation on the same line before the \nfor\n loop will remove redundant array bounds checking and make the loop execute faster).\n\n\n\n\nPreselection\n\n\nFunctions like \nmap\n are not necessarily very intelligent about which columns are required and which are not. The reason is simple: given the operation \nmap(f, t)\n, the \nmap\n method has very little insight into what \nf\n does.\n\n\nThus, in some cases it might improve performance to preselect the columns of interest. For example, extracting a single column, or constructing a new table with a reduced number of columns, may prevent \nmap\n from loading unused values as it materializes each full row as it iterates, and lead to performance improvements.\n\n\n\n\nLazy mapping\n\n\nIt is also worth mentioning the possibility of lazily mapping the values. Functions such as \nmapview\n from \nSplitApplyCombine\n can let you construct a \"view\" of a new table based on existing data. This way you can avoid using up precious resources, like RAM, yet can still call up data upon demand.", 
            "title": "Mapping data"
        }, 
        {
            "location": "/man/map/#mapping-rows-of-data", 
            "text": "Some operations on your data will act by mapping each row of data in a table to a value, or even to new rows (in the case of relational operations). In either case, you are mapping an element of table (which is an array whose elements are rows) to create a new array of computed elements (whose elements may or may not be rows, and thus may or may not be a  Table ).", 
            "title": "Mapping rows of data"
        }, 
        {
            "location": "/man/map/#using-map", 
            "text": "In Julia, the idiomatic way to perform such an operation is with the  map  function, which takes a function and an input array.  One very simple example of this is extracting a column, let's say the column called  name  from a table of people's names and ages.  julia  t = Table(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia  map(row -  row.name, t)\n3-element Array{String,1}:\n  Alice   \n  Bob     \n  Charlie   This has returned and standard Julia array, which will be a  copy  of the array of the  name  column. We could also do a more complicated calculation.  julia  is_old = map(row -  row.age   40, t)\n3-element Array{Bool,1}:\n false\n  true\n false  Depending on your definition of \"old\", we have identified two younger people and one older person - though I suspect that Bob may have a different definition of old than Alice does.  One can also  map  rows, which are  NamedTuple s, to new  NamedTuples , which will naturally result in a new tabular structure. Here is an example where we simply copy the names into a new table (but change the column name to  firstname ):  julia  map(row -  (firstname = row.name,), t)\nTable with 1 column and 3 rows:\n     firstname\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice\n 2 \u2502 Bob\n 3 \u2502 Charlie  Internally, this is leveraging Julia's  similar  interface for constructing new arrays: if we are creating something  similar  to a  Table  with an element type that is a  NamedTuple , we get a new  Table . (The columns themselves are also  similar  to the existing columns, preserving their structure as appropriate). If the output type is not a  NamedTuple , the output array is  similar  to the first column.  Putting this all together, we can create a brand-new table using  map  to manipulate both columns.  julia  map(row -  (name = row.name, is_old = row.age   40), t)\nTable with 2 columns and 3 rows:\n     name     is_old\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    false\n 2 \u2502 Bob      true\n 3 \u2502 Charlie  false", 
            "title": "Using map"
        }, 
        {
            "location": "/man/map/#explicit-for-loops", 
            "text": "One can easily use  for  loops to iterate over your data and perform whatever mapping is required. For example, this loop takes the  first  character of the elements of the  name  column.  julia  function firstletter(t::Table)\n    out = Vector{Char}(undef, length(t))\n\n    for i in 1:length(t)\n        out[i] = first(t.name[i])\n    end\n\n    return out\nend\n\njulia  firstletter(t)\n3-element Array{Char,1}:\n 'A'\n 'B'\n 'C'  Julia will use the type information it knows about  t  to create fast, compiled code. (Pro tip: to make the above loop  optimal , adding an  @inbounds  annotation on the same line before the  for  loop will remove redundant array bounds checking and make the loop execute faster).", 
            "title": "Explicit for loops"
        }, 
        {
            "location": "/man/map/#preselection", 
            "text": "Functions like  map  are not necessarily very intelligent about which columns are required and which are not. The reason is simple: given the operation  map(f, t) , the  map  method has very little insight into what  f  does.  Thus, in some cases it might improve performance to preselect the columns of interest. For example, extracting a single column, or constructing a new table with a reduced number of columns, may prevent  map  from loading unused values as it materializes each full row as it iterates, and lead to performance improvements.", 
            "title": "Preselection"
        }, 
        {
            "location": "/man/map/#lazy-mapping", 
            "text": "It is also worth mentioning the possibility of lazily mapping the values. Functions such as  mapview  from  SplitApplyCombine  can let you construct a \"view\" of a new table based on existing data. This way you can avoid using up precious resources, like RAM, yet can still call up data upon demand.", 
            "title": "Lazy mapping"
        }, 
        {
            "location": "/man/filter/", 
            "text": "Finding data\n\n\nFrequently, we need to find data (i.e. rows of the table) that matches certain criteria, and there are multiple mechanisms for achieving this in Julia. Here we will briefly review \nmap\n, \nfindall\n and \nfilter\n as options.\n\n\n\n\nmap(predicate, table)\n\n\nFollowing the previous section, we can identify row satisfying an arbitrary predicate using the \nmap\n function. Note that \"predicate\" is just a name for function that takes an input and returns either \ntrue\n or \nfalse\n.\n\n\njulia\n t = Table(name = [\nAlice\n, \nBob\n, \nCharlie\n], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia\n is_old = map(row -\n row.age \n 40, t)\n3-element Array{Bool,1}:\n false\n  true\n false\n\n\n\n\nFinally, we can use \"logical\" (i.e. Boolean) indexing to extract the rows where the predicate is \ntrue\n.\n\n\njulia\n t[is_old]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42\n\n\n\n\nThe \nmap(predicate, table)\n approach will allocate one \nBool\n for each row in the input table - for a total of \nlength(table)\n bytes. \nSplitApplyCombine\n defines a \nmapview\n function to do this lazily.\n\n\n\n\nfindall(predicate, table)\n\n\nIf we wish to locate the indices of the rows where the predicate returns \ntrue\n, we can use Julia's \nfindall\n function.\n\n\njulia\n inds = findall(row -\n row.age \n 40, t)\n1-element Array{Int64,1}:\n 2\n\njulia\n t[inds]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42\n\n\n\n\nThis method may be less resource intensive (result in less memory allocated) if you are expecting a small number of matching rows, returing one \nInt\n per result.\n\n\n\n\nfilter(predicate, table)\n\n\nFinally, if we wish to directly \nfilter\n the table and obtain the rows of interest, we can do that as well.\n\n\njulia\n filter(row -\n row.age \n 40, t)\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42\n\n\n\n\nInternally, the \nfilter\n method may rely on one of the implementations above.\n\n\n\n\nPreselection\n\n\nAs mentioned in other sections, it is frequently worthwhile to preselect the columns relating to your search predicate, to avoid any wastage in fetching from memory values in columns that you don't care about.\n\n\nOne simple example of such a transformation is to first project to the column(s) of interest, followed by using \nmap\n or \nfindall\n to identify the indices of the rows where \npredicate\n is \ntrue\n, and finally to use \ngetindex\n or \nview\n to obtain the result of the full table.\n\n\njulia\n inds = findall(age -\n age \n 40, t.age)\n1-element Array{Int64,1}:\n 2\n\njulia\n t[inds]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42\n\n\n\n\nEasy, peasy!", 
            "title": "Finding data"
        }, 
        {
            "location": "/man/filter/#finding-data", 
            "text": "Frequently, we need to find data (i.e. rows of the table) that matches certain criteria, and there are multiple mechanisms for achieving this in Julia. Here we will briefly review  map ,  findall  and  filter  as options.", 
            "title": "Finding data"
        }, 
        {
            "location": "/man/filter/#mappredicate-table", 
            "text": "Following the previous section, we can identify row satisfying an arbitrary predicate using the  map  function. Note that \"predicate\" is just a name for function that takes an input and returns either  true  or  false .  julia  t = Table(name = [ Alice ,  Bob ,  Charlie ], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Alice    25\n 2 \u2502 Bob      42\n 3 \u2502 Charlie  37\n\njulia  is_old = map(row -  row.age   40, t)\n3-element Array{Bool,1}:\n false\n  true\n false  Finally, we can use \"logical\" (i.e. Boolean) indexing to extract the rows where the predicate is  true .  julia  t[is_old]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42  The  map(predicate, table)  approach will allocate one  Bool  for each row in the input table - for a total of  length(table)  bytes.  SplitApplyCombine  defines a  mapview  function to do this lazily.", 
            "title": "map(predicate, table)"
        }, 
        {
            "location": "/man/filter/#findallpredicate-table", 
            "text": "If we wish to locate the indices of the rows where the predicate returns  true , we can use Julia's  findall  function.  julia  inds = findall(row -  row.age   40, t)\n1-element Array{Int64,1}:\n 2\n\njulia  t[inds]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42  This method may be less resource intensive (result in less memory allocated) if you are expecting a small number of matching rows, returing one  Int  per result.", 
            "title": "findall(predicate, table)"
        }, 
        {
            "location": "/man/filter/#filterpredicate-table", 
            "text": "Finally, if we wish to directly  filter  the table and obtain the rows of interest, we can do that as well.  julia  filter(row -  row.age   40, t)\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42  Internally, the  filter  method may rely on one of the implementations above.", 
            "title": "filter(predicate, table)"
        }, 
        {
            "location": "/man/filter/#preselection", 
            "text": "As mentioned in other sections, it is frequently worthwhile to preselect the columns relating to your search predicate, to avoid any wastage in fetching from memory values in columns that you don't care about.  One simple example of such a transformation is to first project to the column(s) of interest, followed by using  map  or  findall  to identify the indices of the rows where  predicate  is  true , and finally to use  getindex  or  view  to obtain the result of the full table.  julia  inds = findall(age -  age   40, t.age)\n1-element Array{Int64,1}:\n 2\n\njulia  t[inds]\nTable with 2 columns and 1 row:\n     name  age\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 Bob   42  Easy, peasy!", 
            "title": "Preselection"
        }, 
        {
            "location": "/man/reduce/", 
            "text": "Reducing data\n\n\nWe can summarize data using Julia's in-built \nreduce\n and \nmapreduce\n.", 
            "title": "Reducing data"
        }, 
        {
            "location": "/man/reduce/#reducing-data", 
            "text": "We can summarize data using Julia's in-built  reduce  and  mapreduce .", 
            "title": "Reducing data"
        }, 
        {
            "location": "/man/group/", 
            "text": "Grouping data\n\n\nIt is frequently useful to break data appart into different \ngroups\n for processing - a paradigm frequently referred to a the split-apply-combine methodology.\n\n\nIn a powerful environment such as Julia, that fully supports nested containers, it makes sense to represent each group as distinct containers, with an outer container acting as a \"dictionary\" of the groups. This is in contrast to environments with a less rich system of containers, such as SQL, which has popularized a slightly different notion of grouping data into a single flat tabular structure, where one (or more) columns act as the grouping key. Here we focus on the former approach.\n\n\nData can be divided into groups by using the \ngroup\n function from \nSplitApplyCombine\n.\n\n\nCan efficiently summarize the groups using \ngroupreduce\n.\n\n\nMay also also use \ngroupinds\n and \ngroupview\n for efficiency reasons.", 
            "title": "Groupind data"
        }, 
        {
            "location": "/man/group/#grouping-data", 
            "text": "It is frequently useful to break data appart into different  groups  for processing - a paradigm frequently referred to a the split-apply-combine methodology.  In a powerful environment such as Julia, that fully supports nested containers, it makes sense to represent each group as distinct containers, with an outer container acting as a \"dictionary\" of the groups. This is in contrast to environments with a less rich system of containers, such as SQL, which has popularized a slightly different notion of grouping data into a single flat tabular structure, where one (or more) columns act as the grouping key. Here we focus on the former approach.  Data can be divided into groups by using the  group  function from  SplitApplyCombine .  Can efficiently summarize the groups using  groupreduce .  May also also use  groupinds  and  groupview  for efficiency reasons.", 
            "title": "Grouping data"
        }, 
        {
            "location": "/man/group/", 
            "text": "Grouping data\n\n\nIt is frequently useful to break data appart into different \ngroups\n for processing - a paradigm frequently referred to a the split-apply-combine methodology.\n\n\nIn a powerful environment such as Julia, that fully supports nested containers, it makes sense to represent each group as distinct containers, with an outer container acting as a \"dictionary\" of the groups. This is in contrast to environments with a less rich system of containers, such as SQL, which has popularized a slightly different notion of grouping data into a single flat tabular structure, where one (or more) columns act as the grouping key. Here we focus on the former approach.\n\n\nData can be divided into groups by using the \ngroup\n function from \nSplitApplyCombine\n.\n\n\nCan efficiently summarize the groups using \ngroupreduce\n.\n\n\nMay also also use \ngroupinds\n and \ngroupview\n for efficiency reasons.", 
            "title": "Joining data"
        }, 
        {
            "location": "/man/group/#grouping-data", 
            "text": "It is frequently useful to break data appart into different  groups  for processing - a paradigm frequently referred to a the split-apply-combine methodology.  In a powerful environment such as Julia, that fully supports nested containers, it makes sense to represent each group as distinct containers, with an outer container acting as a \"dictionary\" of the groups. This is in contrast to environments with a less rich system of containers, such as SQL, which has popularized a slightly different notion of grouping data into a single flat tabular structure, where one (or more) columns act as the grouping key. Here we focus on the former approach.  Data can be divided into groups by using the  group  function from  SplitApplyCombine .  Can efficiently summarize the groups using  groupreduce .  May also also use  groupinds  and  groupview  for efficiency reasons.", 
            "title": "Grouping data"
        }, 
        {
            "location": "/man/data/", 
            "text": "Data representation", 
            "title": "Data representation"
        }, 
        {
            "location": "/man/data/#data-representation", 
            "text": "", 
            "title": "Data representation"
        }, 
        {
            "location": "/man/acceleratedarrays/", 
            "text": "Acceleration Indices with \nAcceleratedArrays\n\n\nDatabase systems have evolved many performance tricks over the years to achieve efficiency and scalability. In an environment such as a SQL RDBMS, much effort is put into the creation of an efficient \"query planner\" that will essentially construct a small computer program, ultimately made up of nested loops, searching, mapping and filtering operations, to perform a query. However, the second \"magic\" ingredient used by an RDBMS for performance are secondary \"acceleration indices\", which are pre-calculated views of the data. These views help queries find data that match certain conditions - a hash-map index well let us locate a matching entry in \nO\n(1), or a sort-based index will let us quickly locate \nall\n the cells less than (or more than) a certain value.\n\n\nFor at least some of the kinds of data analytics performed in Julia, it may be possible to expect the programmer to write and execute their own query plan - that is, to understand their data model, to predict the \"statistics\" regarding the size of and other properties of the data, and to come up with their own rough order of operations that may be efficient. Thus, we may not need to implement a complete query planner to make a viable platform for data analytics in Julia - however, we will absolutely need acceleration indices to perform each elementary operation fast. In the worst case, the programmer would have to construct their own hash-maps and sort-indices (and use them in their own hand-written loops) to obtain peak performance.\n\n\nThe \nAcceleratedArrays\n package exists to provide a way of attaching secondary acceleration indices to any array in Julia, to speed up operations such as \nfilter\n, \nfindall\n, \ngroup\n and \ninnerjoin\n in a transparent and generic way. These acceleration indices can be attached to arbitrary columns (or indeed, entire \nTable\ns). These indices remain silently attached to their parent array until they encounter an operation they can accelerate. The user is free to write \ngeneric\n code to execute their query, and the presence of the acceleration index will only act to speed up the resulting specialized algorithm constructed by Julia's compiler.\n\n\nThis system allows for an extensible set of acceleration indices - such as accelerated spatial lookup using a spatial search tree, or an inverted index for searching for words in text fields. \n\n\nNote: by default, the \ninnerjoin\n operation will construct a hash-based index to perform a join on two unindexed data sources, meaning most basic data operations can be achieved at reasonable speeds.", 
            "title": "Acceleration indices"
        }, 
        {
            "location": "/man/acceleratedarrays/#acceleration-indices-with-acceleratedarrays", 
            "text": "Database systems have evolved many performance tricks over the years to achieve efficiency and scalability. In an environment such as a SQL RDBMS, much effort is put into the creation of an efficient \"query planner\" that will essentially construct a small computer program, ultimately made up of nested loops, searching, mapping and filtering operations, to perform a query. However, the second \"magic\" ingredient used by an RDBMS for performance are secondary \"acceleration indices\", which are pre-calculated views of the data. These views help queries find data that match certain conditions - a hash-map index well let us locate a matching entry in  O (1), or a sort-based index will let us quickly locate  all  the cells less than (or more than) a certain value.  For at least some of the kinds of data analytics performed in Julia, it may be possible to expect the programmer to write and execute their own query plan - that is, to understand their data model, to predict the \"statistics\" regarding the size of and other properties of the data, and to come up with their own rough order of operations that may be efficient. Thus, we may not need to implement a complete query planner to make a viable platform for data analytics in Julia - however, we will absolutely need acceleration indices to perform each elementary operation fast. In the worst case, the programmer would have to construct their own hash-maps and sort-indices (and use them in their own hand-written loops) to obtain peak performance.  The  AcceleratedArrays  package exists to provide a way of attaching secondary acceleration indices to any array in Julia, to speed up operations such as  filter ,  findall ,  group  and  innerjoin  in a transparent and generic way. These acceleration indices can be attached to arbitrary columns (or indeed, entire  Table s). These indices remain silently attached to their parent array until they encounter an operation they can accelerate. The user is free to write  generic  code to execute their query, and the presence of the acceleration index will only act to speed up the resulting specialized algorithm constructed by Julia's compiler.  This system allows for an extensible set of acceleration indices - such as accelerated spatial lookup using a spatial search tree, or an inverted index for searching for words in text fields.   Note: by default, the  innerjoin  operation will construct a hash-based index to perform a join on two unindexed data sources, meaning most basic data operations can be achieved at reasonable speeds.", 
            "title": "Acceleration Indices with AcceleratedArrays"
        }, 
        {
            "location": "/man/io/", 
            "text": "Input and output\n\n\nTables.jl interface provides I/O.", 
            "title": "Input and output"
        }, 
        {
            "location": "/man/io/#input-and-output", 
            "text": "Tables.jl interface provides I/O.", 
            "title": "Input and output"
        }
    ]
}